"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[37991],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>p});var s=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,s,o=function(e,n){if(null==e)return{};var t,s,o={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=s.createContext({}),d=function(e){var n=s.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=d(e.components);return s.createElement(i.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},h=s.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=d(t),h=o,p=c["".concat(i,".").concat(h)]||c[h]||g[h]||a;return t?s.createElement(p,r(r({ref:n},u),{},{components:t})):s.createElement(p,r({ref:n},u))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=h;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[c]="string"==typeof e?e:o,r[1]=l;for(var d=2;d<a;d++)r[d]=t[d];return s.createElement.apply(null,r)}return s.createElement.apply(null,t)}h.displayName="MDXCreateElement"},2795:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>g,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var s=t(87462),o=(t(67294),t(3905));const a={},r="RFC 006: Handlers",l={unversionedId:"build/rfc/rfc-006-handlers",id:"version-0.52/build/rfc/rfc-006-handlers",title:"RFC 006: Handlers",description:"Changelog",source:"@site/versioned_docs/version-0.52/build/rfc/rfc-006-handlers.md",sourceDirName:"build/rfc",slug:"/build/rfc/rfc-006-handlers",permalink:"/v0.52/build/rfc/rfc-006-handlers",draft:!1,tags:[],version:"0.52",frontMatter:{},sidebar:"buildSidebar",previous:{title:"RFC 005: Optimistic Execution",permalink:"/v0.52/build/rfc/rfc-005-optimistic-execution"},next:{title:"RFC {RFC-NUMBER}:",permalink:"/v0.52/build/rfc/rfc-template"}},i={},d=[{value:"Changelog",id:"changelog",level:2},{value:"Background",id:"background",level:2},{value:"Proposal",id:"proposal",level:2},{value:"Pre and Post Message Handlers",id:"pre-and-post-message-handlers",level:3},{value:"Message and Query Handlers",id:"message-and-query-handlers",level:3},{value:"Consensus Messages",id:"consensus-messages",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:3},{value:"Discussion",id:"discussion",level:2}],u={toc:d},c="wrapper";function g(e){let{components:n,...t}=e;return(0,o.kt)(c,(0,s.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"rfc-006-handlers"},"RFC 006: Handlers"),(0,o.kt)("h2",{id:"changelog"},"Changelog"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"January 26, 2024: Initialized")),(0,o.kt)("h2",{id:"background"},"Background"),(0,o.kt)("p",null,"The Cosmos SDK has a very powerful and flexible module system that has been tested\nand proven to be very good in production. The design of how messages are handled\nis built around Protobuf services and gRPC. This design was proposed and implemented\nduring a time when we migrated from Amino to Protocol Buffers. This design has\nfulfilled the needs of users today. While this design is useful it has caused a\nelevated learning curve to be adopted by users. Today, these services are the\nonly way to write a module. This RFC proposes a new design that simplifies the\ndesign and enables new use cases we are seeing today."),(0,o.kt)("p",null,"Taking a step back, we have seen the emergence of rollups and proving technologies.\nThese technologies enable new use cases and new methods of achieving various goals.\nWhen we look at things like proving we look to ",(0,o.kt)("a",{parentName:"p",href:"https://TinyGo.org/"},"TinyGo"),". When\nwe have attempted to use TinyGo with existing modules we have run into a hiccup,\nthe use of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/TinyGo-org/TinyGo/issues/2814"},"gRPC")," within modules.\nThis has led us to look at a design which would allow the usage of TinyGo and\nother technologies."),(0,o.kt)("p",null,"We looked at TinyGo for our first target in order to compile down to a 32 bit environment which could be used with\nthings like ",(0,o.kt)("a",{parentName:"p",href:"https://www.risczero.com/"},"Risc-0"),", ",(0,o.kt)("a",{parentName:"p",href:"https://fluentlabs.xyz/"},"Fluent")," and other technologies. When speaking with the teams behind these technologies\nwe found that they were interested in using the Cosmos SDK but were unable to due to being unable to use TinyGo or the\nCosmos SDK go code in a 32 bit environment."),(0,o.kt)("p",null,"The Cosmos SDK team has been hard at work over the last few months designing and implementing a modular core layer, with\nthe idea that proving can be enabled later on. This design allows us to push the design of what can be done with the\nCosmos SDK to the next level. In the future when we have proving tools and technologies integrated parts of the new core\nlayer will be able to be used in conjunction with proving technologies without the need to rewrite the stack."),(0,o.kt)("h2",{id:"proposal"},"Proposal"),(0,o.kt)("p",null,"This proposal is around enabling modules to be compiled to an environment in which they can be used with TinyGo and/or\ndifferent proving technologies."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note the usage of handlers in modules is optional, modules can still use the existing design. This design is meant to\nbe a new way to write modules, with proving in mind, and is not meant to replace the existing design.")),(0,o.kt)("p",null,"This proposal is for server/v2. Baseapp will continue to work in the same way as it does today."),(0,o.kt)("h3",{id:"pre-and-post-message-handlers"},"Pre and Post Message Handlers"),(0,o.kt)("p",null,"In the Cosmos SDK, there exists hooks on messages and execution of function calls. Separating the two we will focus on\nmessage hooks. When a message is implemented it can be unknown if others will use the module and if a message will need\nhooks. When hooks are needed before or after a message, users are required to fork the module. This is not ideal as it\nleads to a lot of forks of modules and a lot of code duplication."),(0,o.kt)("p",null,"Pre and Post message handlers solve this issue. Where we allow modules to register listeners for messages in order to\nexecute something before and/or after the message. Although hooks can be bypassed by doing keeper function calls, we can\nassume that as we shift the communication design of the SDK to use messages instead of keeper calls it will be safe to\nassume that the bypass surface of hooks will reduce to zero."),(0,o.kt)("p",null,"If an application developer would like to check the sender of funds before the message is executed they can\nregister a pre message handler. If the message is called by a user the pre message handler will be called with the custom\nlogic. If the sender is not allowed to send funds the pre-message handler can return an error and the message will not be\nexecuted."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: This is different from the ante-handler and post-handler we have today. These will still exist in the same form.")),(0,o.kt)("p",null,"A module can register handlers for any or all message(s), this allows for modules to be extended without the need to fork."),(0,o.kt)("p",null,"A module will implement the below for a pre-message hook:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'package core_appmodule\n\nimport (\n    "context"\n\n    "google.golang.org/protobuf/runtime/protoiface"\n)\n\ntype PreMsgHandlerRouter interface {\n    // RegisterGlobalPreMsgHandler will register a pre msg handler that hooks before any message executes.\n    // Handler will be called before ANY message executes.\n    RegisterGlobalPreMsgHandler(handler func(ctx context.Context, msg transaction.Msg) error)\n    // RegisterPreMsgHandler will register a pre msg handler that hooks before the provided message\n    // with the given message name executes. Handler will be called before the message is executed\n    // by the module.\n    RegisterPreMsgHandler(msgName string, handler func(ctx context.Context, msg transaction.Msg) error)\n}\n\ntype HasPreMsgHandler interface {\n    RegisterPreMsgHandler(router PreMsgHandlerRouter)\n}\n')),(0,o.kt)("p",null,"A module will implement the below for a postmessage hook:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package core_appmodule\n\nimport (\n    "context"\n\n    "google.golang.org/protobuf/runtime/protoiface"\n)\n\ntype PostMsgHandlerRouter interface {\n    // RegisterGlobalPostMsgHandler will register a post msg handler that hooks after any message executes.\n    // Handler will be called after ANY message executes, alongside the response.\n    RegisterGlobalPostMsgHandler(handler func(ctx context.Context, msg, msgResp transaction.Msg) error)\n    // RegisterPostMsgHandler will register a pre msg handler that hooks after the provided message\n    // with the given message name executes. Handler will be called after the message is executed\n    // by the module, alongside the response returned by the module.\n    RegisterPostMsgHandler(msgName string, handler func(ctx context.Context, msg, msgResp transaction.Msg) error)\n}\n\ntype HasPostMsgHandler interface {\n    RegisterPostMsgHandler(router PostMsgHandlerRouter)\n}\n')),(0,o.kt)("p",null,"We note the following behaviors:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A pre msg handler returning an error will yield to a state transition revert."),(0,o.kt)("li",{parentName:"ul"},"A post msg handler returning an error will yield to a state transition revert."),(0,o.kt)("li",{parentName:"ul"},"A post msg handler will not be called if the execution handler (message handler) fails."),(0,o.kt)("li",{parentName:"ul"},"A post msg handler will be called only if the execution handler succeeds alongside the response provided by the execution handler.")),(0,o.kt)("h3",{id:"message-and-query-handlers"},"Message and Query Handlers"),(0,o.kt)("p",null,"Similar to the above design, message handlers will allow the application developer to replace existing gRPC based services\nwith handlers. This enables the module to be compiled down to TinyGo, and abandon the gRPC dependency. As mentioned\nupgrading the modules immediately is not mandatory, module developers can do so in a gradual way. Application developers have the option to use the existing gRPC services or the new handlers."),(0,o.kt)("p",null,"For message handlers we propose the introduction of the following core/appmodule interfaces and functions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package core_appmodule\n\nimport (\n    "context"\n\n    "google.golang.org/protobuf/runtime/protoiface"\n)\n\ntype MsgHandlerRouter interface {\n    RegisterMsgHandler(msgName string, handler func(ctx context.Context, msg transaction.Msg) (msgResp transaction.Msg, err error))\n}\n\ntype HasMsgHandler interface {\n    RegisterMsgHandlers(router MsgHandlerRouter)\n}\n\n// RegisterMsgHandler is a helper function to retain type safety when creating handlers, so we do not need to cast messages.\nfunc RegisterMsgHandler[Req, Resp transaction.Msg](router MsgHandlerRouter, handler func(ctx context.Context, req Req) (resp Resp, err error)) {\n    // impl detail\n}\n')),(0,o.kt)("p",null,"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"package bank\n\nfunc (b BankKeeper) Send(ctx context.Context, msg bank.MsgSend) (bank.MsgSendResponse, error) {\n    // logic\n}\n\nfunc (b BankModule) RegisterMsgHandlers(router core_appmodule.MsgHandlerRouter) {\n    // the RegisterMsgHandler function takes care of doing type casting and conversions, ensuring we retain type safety\n    core_appmodule.RegisterMsgHandler(router, b.Send)\n}\n\n")),(0,o.kt)("p",null,"This change is fully state machine compatible as, even if we were using gRPC, messages were\nrouted using the message type name and not the gRCP method name."),(0,o.kt)("p",null,"We apply the same principles of MsgHandlers to QueryHandlers, by introducing a new core/appmodule interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package core_appmodule\n\nimport (\n    "context"\n\n    "google.golang.org/protobuf/runtime/protoiface"\n)\n\ntype QueryHandlerRouter interface {\n    RegisterQueryHandler(msgName string, handler func(ctx context.Context, req transaction.Msg) (resp transaction.Msg, err error))\n}\n\ntype HasQueryHandler interface {\n    RegisterQueryHandlers(router QueryHandlerRouter)\n}\n\n// RegisterQueryHandler is a helper function to retain type safety when creating handlers, so we do not need to cast messages.\nfunc RegisterQueryHandler[Req, Resp transaction.Msg](router QueryHandlerRouter, handler func(ctx context.Context, req Req) (resp Resp, err error)) {\n    // impl detail\n}\n\n')),(0,o.kt)("p",null,"The difference between gRPC handlers and query handlers is that we expect query handlers to be deterministic and usable\nin consensus by other modules. Non consensus queries should be registered outside of the state machine itself, and we will\nprovide guidelines on how to do so with serverv2."),(0,o.kt)("p",null,"As a consequence queries would be now mapped by their message name."),(0,o.kt)("p",null,"We can provide JSON exposure of the Query APIs following this rest API format:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"method: POST\npath: /msg_name\nReqBody: protojson.Marshal(msg)\n----\nRespBody: protojson.Marshal(msgResp)\n")),(0,o.kt)("h3",{id:"consensus-messages"},"Consensus Messages"),(0,o.kt)("p",null,"Similar to the above design, consensus messages will allow the underlying consensus engine to speak to the modules. Today we get consensus related information from ",(0,o.kt)("inlineCode",{parentName:"p"},"sdk.Context"),". In server/v2 we are unable to continue with this design due to the forced dependency leakage of comet throughout the repo. Secondly, while we already have ",(0,o.kt)("inlineCode",{parentName:"p"},"cometInfo")," if we were to put this on the new execution client we would be tying CometBFT to the application manager and STF."),(0,o.kt)("p",null,"In the case of CometBFT, consensus would register handlers for consensus messages for evidence, voteinfo and consensus params. This would allow the consensus engine to speak to the modules."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"package consensus\n\nfunc (b ConsensusKeeper) ConsensusParams(ctx context.Context, msg bank.MsgConsensusParams) (bank.MsgConsensusParamsResponse, error) {\n    // logic\n}\n\nfunc (b CircuitModule) RegisterConsensusHandlers(router core_appmodule.MsgHandlerRouter) {\n    // the RegisterConsensusHandler function takes care of doing type casting and conversions, ensuring we retain type safety\n    core_appmodule.RegisterConsensusHandler(router, b.Send)\n}\n\n")),(0,o.kt)("h2",{id:"consequences"},"Consequences"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"REST endpoints for message and queries change due to lack of services and gRPC gateway annotations."),(0,o.kt)("li",{parentName:"ul"},"When using gRPC directly, one must query a schema endpoint in order to see all possible messages and queries.")),(0,o.kt)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,o.kt)("p",null,"The way to interact with modules changes, REST and gRPC will still be available."),(0,o.kt)("h3",{id:"positive"},"Positive"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Allows modules to be compiled to TinyGo."),(0,o.kt)("li",{parentName:"ul"},"Reduces the cosmos-sdk's learning curve, since understanding gRPC semantics is not a must anymore."),(0,o.kt)("li",{parentName:"ul"},"Allows other modules to extend existing modules behaviour using pre and post msg handlers, without forking."),(0,o.kt)("li",{parentName:"ul"},"The system becomes overall more simple as gRPC is not anymore a hard dependency and requirement for the state machine."),(0,o.kt)("li",{parentName:"ul"},"Reduces the need on sdk.Context"),(0,o.kt)("li",{parentName:"ul"},"Concurrently safe"),(0,o.kt)("li",{parentName:"ul"},"Reduces public interface of modules")),(0,o.kt)("h3",{id:"negative"},"Negative"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Pre, Post and Consensus msg handlers are a new concept that module developers need to learn (although not immediately).")),(0,o.kt)("h3",{id:"neutral"},"Neutral"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"{neutral consequences}")),(0,o.kt)("h3",{id:"references"},"References"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Links to external materials needed to follow the discussion may be added here."),(0,o.kt)("p",{parentName:"blockquote"},"In addition, if the discussion in a request for comments leads to any design\ndecisions, it may be helpful to add links to the ADR documents here after the\ndiscussion has settled.")),(0,o.kt)("h2",{id:"discussion"},"Discussion"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"This section contains the core of the discussion."),(0,o.kt)("p",{parentName:"blockquote"},"There is no fixed format for this section, but ideally changes to this\nsection should be updated before merging to reflect any discussion that took\nplace on the PR that made those changes.")))}g.isMDXComponent=!0}}]);