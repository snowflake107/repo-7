"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[4788],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=i,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},80526:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(87462),i=(n(67294),n(3905));const o={},r="x/accounts",s={unversionedId:"build/modules/accounts/README",id:"build/modules/accounts/README",title:"x/accounts",description:"The x/accounts module enhances the Cosmos SDK by providing tools and infrastructure for creating advanced smart accounts.",source:"@site/docs/build/modules/accounts/README.md",sourceDirName:"build/modules/accounts",slug:"/build/modules/accounts/",permalink:"/main/build/modules/accounts/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"buildSidebar",previous:{title:"x/upgrade",permalink:"/main/build/modules/upgrade/"},next:{title:"x/circuit",permalink:"/main/build/modules/circuit/"}},c={},l=[{value:"Basics",id:"basics",level:2},{value:"Example account creation",id:"example-account-creation",level:3},{value:"Basic",id:"basic",level:4},{value:"State Isolation",id:"state-isolation",level:5},{value:"Init",id:"init",level:4},{value:"Execute Handlers",id:"execute-handlers",level:4},{value:"Query Handlers",id:"query-handlers",level:4},{value:"The Account Constructor",id:"the-account-constructor",level:4},{value:"App Wiring",id:"app-wiring",level:2},{value:"Depinject Method",id:"depinject-method",level:3},{value:"Manual Method",id:"manual-method",level:3},{value:"The accountsstd Package",id:"the-accountsstd-package",level:3},{value:"Interfaces via Messages and Queries",id:"interfaces-via-messages-and-queries",level:3},{value:"Full Examples",id:"full-examples",level:3},{value:"The Authentication Interface",id:"the-authentication-interface",level:2},{value:"Authentication Mechanism",id:"authentication-mechanism",level:3},{value:"AnteHandler in the SDK",id:"antehandler-in-the-sdk",level:4},{value:"Authentication Flow for x/accounts Module",id:"authentication-flow-for-xaccounts-module",level:4},{value:"Authentication Interface Requirement",id:"authentication-interface-requirement",level:5},{value:"Sequence Diagram",id:"sequence-diagram",level:6},{value:"Implementing the Authentication Interface",id:"implementing-the-authentication-interface",level:3},{value:"Key Implementation Points",id:"key-implementation-points",level:4},{value:"Implementation example",id:"implementation-example",level:5},{value:"Supporting Custom Accounts in the x/auth gRPC Server",id:"supporting-custom-accounts-in-the-xauth-grpc-server",level:2},{value:"Overview",id:"overview",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Usage Notes",id:"usage-notes",level:3},{value:"Genesis",id:"genesis",level:2},{value:"Creating accounts on genesis",id:"creating-accounts-on-genesis",level:3}],u={toc:l},p="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"xaccounts"},"x/accounts"),(0,i.kt)("p",null,"The x/accounts module enhances the Cosmos SDK by providing tools and infrastructure for creating advanced smart accounts."),(0,i.kt)("h2",{id:"basics"},"Basics"),(0,i.kt)("p",null,"An account can be thought of as a simplified cosmos-sdk module that supports multiple deployments. This means:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"A single account implementation can be deployed to multiple addresses, similar to how CosmWasm allows multiple contract instances from one WASM upload.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Each account address is mapped to its corresponding account code.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Accounts maintain their own state partition, similar to modules.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Accounts can define both message and query handlers."))),(0,i.kt)("p",null,"This design allows for flexible and reusable account structures within the ecosystem."),(0,i.kt)("h3",{id:"example-account-creation"},"Example account creation"),(0,i.kt)("h4",{id:"basic"},"Basic"),(0,i.kt)("p",null,"Defining an account begins with creating a struct that encapsulates the account's state. If the account has no state, the\nstruct is empty ",(0,i.kt)("inlineCode",{parentName:"p"},"type Account struct{}"),"."),(0,i.kt)("p",null,"By default, accounts utilize collections to manage their state."),(0,i.kt)("h5",{id:"state-isolation"},"State Isolation"),(0,i.kt)("p",null,"It's crucial to understand that an account's state is isolated. This means:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"States are not shared between accounts of different types."),(0,i.kt)("li",{parentName:"ol"},"States are not shared even between accounts of the same type.")),(0,i.kt)("p",null,"For example, consider two accounts of type Counter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'One located at address "cosmos123"'),(0,i.kt)("li",{parentName:"ul"},'Another at address "cosmos456"')),(0,i.kt)("p",null,"These accounts do not share the same collections.Item instance. Instead, each maintains its own separate state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Account struct {\n // We will define that the account contains in its state a counter, it's an item.\n // It could also be a map or whatever!\n Counter collections.Item[uint64]\n}\n")),(0,i.kt)("h4",{id:"init"},"Init"),(0,i.kt)("p",null,"Creating an account begins with defining its init message. This message is processed when an account is created, similar to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"instantiate")," method in a CosmWasm contract"),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"constructor")," in an EVM contract")),(0,i.kt)("p",null,"For an account to be a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"x/account")," implementer, it must define both:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An ",(0,i.kt)("inlineCode",{parentName:"li"},"Init")," method"),(0,i.kt)("li",{parentName:"ol"},"An init message")),(0,i.kt)("p",null,"We start by defining the ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgInit")," and its corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgInitResponse")," as protobuf messages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgInit {\n   uint64 counter = 1;\n}\n\nmessage MsgInitResponse {}\n")),(0,i.kt)("p",null,"Next, we implement the Init method, which sets the initial counter. We also implement a method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Account")," interface. This method:"),(0,i.kt)("p",null,"Signals to the x/accounts runtime what the Init entrypoint is\nPerforms some generic operations to maintain type safety in the system"),(0,i.kt)("p",null,"Here's the Go implementation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package counter\n\nimport (\n    "context"\n    "cosmossdk.io/x/accounts/accountstd"\n)\n\ntype Account struct {\n    Counter collections.Item[uint64]\n}\n\nfunc (a Account) Init(ctx context.Context, msg *MsgInit) (*MsgInitResponse, error) {\n    err := a.Counter.Set(ctx, msg.Counter)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &MsgInitResponse{}, nil\n}\n\nfunc (a Account) RegisterInitHandler(builder *accountstd.InitBuilder) {\n    accountstd.RegisterInitHandler(builder, a.Init)\n}\n')),(0,i.kt)("h4",{id:"execute-handlers"},"Execute Handlers"),(0,i.kt)("p",null,"Execute handlers are methods that an account can execute, defined as messages. These executions can be triggered:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"During block execution (not queries) through transactions"),(0,i.kt)("li",{parentName:"ul"},"During begin or end block")),(0,i.kt)("p",null,"To define an execute handler, we start by creating its proto message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgIncreaseCounter {\n   uint64 amount = 1;\n}\n\nmessage MsgIncreaseCounterResponse {\n   uint64 new_value = 1;\n}\n")),(0,i.kt)("p",null,"Next, we implement the handling code for this message and register it using the ",(0,i.kt)("inlineCode",{parentName:"p"},"RegisterExecuteHandlers")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package counter\n\nimport (\n    "context"\n    "cosmossdk.io/x/accounts/accountstd"\n)\n\ntype Account struct {\n    Counter collections.Item[uint64]\n}\n\nfunc (a Account) Init(ctx context.Context, msg *MsgInit) (*MsgInitResponse, error) {\n    err := a.Counter.Set(ctx, msg.Counter)\n    if err != nil {\n        return nil, err\n    }\n    return &MsgInitResponse{}, nil\n}\n\n// Handler for MsgIncreaseCounter\nfunc (a Account) IncreaseCounter(ctx context.Context, msg *MsgIncreaseCounter) (*MsgIncreaseCounterResponse, error) {\n    counter, err := a.Counter.Get(ctx)\n    if err != nil {\n        return nil, err\n    }\n    \n    newValue := counter + msg.Amount\n    err = a.Counter.Set(ctx, newValue)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &MsgIncreaseCounterResponse{NewValue: newValue}, nil\n}\n\n// Registration of the handler in the runtime\nfunc (a Account) RegisterExecuteHandlers(builder *accountstd.ExecuteBuilder) {\n    accountstd.RegisterExecuteHandler(builder, a.IncreaseCounter)\n}\n\nfunc (a Account) RegisterInitHandler(builder *accountstd.InitBuilder) {\n    accountstd.RegisterInitHandler(builder, a.Init)\n}\n')),(0,i.kt)("p",null,"This implementation defines an IncreaseCounter method that handles the MsgIncreaseCounter message, updating the counter\nvalue and returning the new value in the response."),(0,i.kt)("h4",{id:"query-handlers"},"Query Handlers"),(0,i.kt)("p",null,"Query Handlers are read-only methods implemented by an account to expose information about itself. This information can be accessed by:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"External clients (e.g., CLI, wallets)"),(0,i.kt)("li",{parentName:"ul"},"Other modules and accounts within the system")),(0,i.kt)("p",null,"Query handlers can be invoked:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"By external clients"),(0,i.kt)("li",{parentName:"ol"},"During block execution")),(0,i.kt)("p",null,"To define a query handler, we follow a similar process to execute handlers:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Define the request and response proto messages:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"message QueryCounter {}\n\nmessage QueryCounterResponse {\n   uint64 value = 1;\n}\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Implement and register the query handler:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package counter\n\nimport (\n    "context"\n    "cosmossdk.io/x/accounts/accountstd"\n)\n\nfunc (a Account) QueryCounter(ctx context.Context, _ *QueryCounterRequest) (*QueryCounterResponse, error) {\n    counter, err := a.Counter.Get(ctx)\n    if err != nil {\n        return nil, err\n    }\n    return &QueryCounterResponse{\n        Value: counter,\n    }, nil\n}\n\nfunc (a Account) RegisterQueryHandlers(builder *accountstd.QueryBuilder) {\n    accountstd.RegisterQueryHandler(builder, a.QueryCounter)\n}\n')),(0,i.kt)("p",null,"This implementation defines a ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryCounter")," method that retrieves the current counter value and returns it in the response.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"RegisterQueryHandlers")," method registers this query handler with the system."),(0,i.kt)("h4",{id:"the-account-constructor"},"The Account Constructor"),(0,i.kt)("p",null,"After creating our basic counter account, we implement the account constructor function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package counter\n\nimport (\n   "cosmossdk.io/collections"\n   "cosmossdk.io/x/accounts/accountstd"\n)\n\nfunc NewAccount(deps accountstd.Dependencies) (Account, error) {\n   return Account{\n      Counter: collections.NewItem(deps.SchemaBuilder, CounterPrefix, "counter", collections.Uint64Value),\n   }, nil\n}\n\ntype Account struct {\n   Counter collections.Item[uint64]\n}\n\n// Rest of the Account implementation...\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"accountstd.Dependencies")," type provides an environment with essential components:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"AddressCodec"),": For encoding and decoding addresses"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SchemaBuilder"),": For schema construction (handled by the accounts module)"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"HeaderService"),": For accessing block header information"),(0,i.kt)("li",{parentName:"ol"},"Other useful services and utilities")),(0,i.kt)("p",null,"These dependencies allow the account to interact with the blockchain system."),(0,i.kt)("h2",{id:"app-wiring"},"App Wiring"),(0,i.kt)("p",null,"Note: This assumes you've already wired the ",(0,i.kt)("inlineCode",{parentName:"p"},"x/accounts")," module in your application. If not, refer to the Simapp example."),(0,i.kt)("p",null,"After creating our basic account, we wire it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"x/accounts")," module."),(0,i.kt)("h3",{id:"depinject-method"},"Depinject Method"),(0,i.kt)("p",null,"Define the depinject constructor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package counterdepinject\n\nfunc ProvideAccount() accountstd.DepinjectAccount {\n    return accountstd.DIAccount("counter", counter.NewAccount)\n}\n')),(0,i.kt)("p",null,"Add this to the application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"package app\n\nfunc NewApp() *App {\n    // ...\n    appConfig = depinject.Configs(\n        AppConfig(),\n        depinject.Supply(\n            appOpts,\n            logger,\n        ),\n        depinject.Provide(\n            counterdepinject.ProvideAccount,\n        ),\n    )\n    // ...\n}\n")),(0,i.kt)("h3",{id:"manual-method"},"Manual Method"),(0,i.kt)("p",null,"Add the account to the x/accounts Keeper:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'accountsKeeper, err := accounts.NewKeeper(\n    appCodec,\n    runtime.NewEnvironment(/* ... */),\n    signingCtx.AddressCodec(),\n    appCodec.InterfaceRegistry(),\n    \n    accountstd.AddAccount("counter", counter.NewAccount), // Add account here\n    // Add more accounts if needed\n)\n')),(0,i.kt)("p",null,"Choose the method that best fits your application structure."),(0,i.kt)("h3",{id:"the-accountsstd-package"},"The accountsstd Package"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"accountsstd")," package provides utility functions for use within account init, execution, or query handlers. Key functions include:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Whoami()"),": Retrieves the address of the current account."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Sender()"),": Gets the address of the transaction sender (not available in queries)."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Funds()"),": Retrieves funds provided by the sender during Init or Execution."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ExecModule()"),": Allows the account to execute a module message.\nNote: Impersonation is prevented. An account can't send messages on behalf of others."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"QueryModule()"),": Enables querying a module.")),(0,i.kt)("p",null,"These functions, along with others, facilitate account operations and interactions within the system.\nFor a comprehensive list of available utilities, refer to the Go documentation."),(0,i.kt)("h3",{id:"interfaces-via-messages-and-queries"},"Interfaces via Messages and Queries"),(0,i.kt)("p",null,"Accounts can handle various messages and queries, allowing for flexible interface definitions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Multiple account types can handle the same message or query."),(0,i.kt)("li",{parentName:"ol"},"Different accounts (even with the same type but different addresses) can process identical messages or queries.")),(0,i.kt)("p",null,"This flexibility enables defining interfaces as common sets of messages and/or queries that accounts can handle."),(0,i.kt)("p",null,"Example: Transaction Authentication"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We define a ",(0,i.kt)("inlineCode",{parentName:"li"},"MsgAuthenticate")," message."),(0,i.kt)("li",{parentName:"ul"},"Any account capable of handling ",(0,i.kt)("inlineCode",{parentName:"li"},"MsgAuthenticate")," is considered to implement the ",(0,i.kt)("inlineCode",{parentName:"li"},"Authentication")," interface."),(0,i.kt)("li",{parentName:"ul"},"This approach allows for standardized interaction patterns across different account types.")),(0,i.kt)("p",null,"(Note: More details on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Authentication")," interface will be provided later.)"),(0,i.kt)("h3",{id:"full-examples"},"Full Examples"),(0,i.kt)("p",null,"Some examples can be found in the ",(0,i.kt)("a",{parentName:"p",href:"./defaults"},"defaults")," package."),(0,i.kt)("h2",{id:"the-authentication-interface"},"The Authentication Interface"),(0,i.kt)("p",null,"x/accounts introduces the ",(0,i.kt)("inlineCode",{parentName:"p"},"Authentication")," interface, allowing for flexible transaction (TX) authentication beyond traditional public key cryptography."),(0,i.kt)("p",null,"Chain developers can implement tailored authentication methods for their accounts. Any account that implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Authentication")," interface can be authenticated within a transaction."),(0,i.kt)("p",null,"To implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Authentication")," interface in x/accounts, an account must expose an execution handler capable of processing a specific message type."),(0,i.kt)("p",null,"The key message type for authentication is ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgAuthenticate"),", which is defined in the module's protocol buffer files:"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"./proto/cosmos/accounts/interfaces/account_abstraction/v1/interface.proto"},"interfaces/account_abstraction/v1/interface.proto")),(0,i.kt)("h3",{id:"authentication-mechanism"},"Authentication Mechanism"),(0,i.kt)("h4",{id:"antehandler-in-the-sdk"},"AnteHandler in the SDK"),(0,i.kt)("p",null,"The Cosmos SDK utilizes an ",(0,i.kt)("inlineCode",{parentName:"p"},"AnteHandler")," to verify transaction (TX) integrity. Its primary function is to ensure that the messages within a transaction are correctly signed by the purported sender."),(0,i.kt)("h4",{id:"authentication-flow-for-xaccounts-module"},"Authentication Flow for x/accounts Module"),(0,i.kt)("p",null,"When the ",(0,i.kt)("inlineCode",{parentName:"p"},"AnteHandler")," identifies that a message sender (and transaction signer) belongs to the x/accounts module, it delegates the authentication process to that module."),(0,i.kt)("h5",{id:"authentication-interface-requirement"},"Authentication Interface Requirement"),(0,i.kt)("p",null,"For successful authentication, the account must implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Authentication")," interface. If an account fails to implement this interface, it's considered non-externally owned, resulting in transaction rejection."),(0,i.kt)("h6",{id:"sequence-diagram"},"Sequence Diagram"),(0,i.kt)("mermaid",{value:"graph TD\n    A[Tx Is Received] --\x3e B[Execute Signature Verification Ante Handler]\n    B --\x3e D{Is signer an x/accounts account?}\n    D --\x3e|No| E[Continue with signature verification ante handler]\n    D --\x3e|Yes| F{Does account handle MsgAuthenticate?}\n    F --\x3e|No| G[Fail TX: Non-externally owned account]\n    F --\x3e|Yes| H[Invoke signer account MsgAuthenticate]\n    E --\x3e I[End]\n    G --\x3e I\n    H --\x3e I"}),(0,i.kt)("h3",{id:"implementing-the-authentication-interface"},"Implementing the Authentication Interface"),(0,i.kt)("p",null,"To implement the Authentication interface, an account must handle the execution of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgAuthenticate"),". Here's an example of how to do this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package base\n\nimport (\n   "context"\n   "errors"\n   aa_interface_v1 "github.com/cosmos/cosmos-sdk/x/accounts/interfaces/account_abstraction/v1"\n   "github.com/cosmos/cosmos-sdk/x/accounts/std"\n)\n\n// Account represents a base account structure\ntype Account struct {\n   // Account fields...\n}\n\n// Authenticate implements the authentication flow for an abstracted base account.\nfunc (a Account) Authenticate(ctx context.Context, msg *aa_interface_v1.MsgAuthenticate) (*aa_interface_v1.MsgAuthenticateResponse, error) {\n   if !accountstd.SenderIsAccountsModule(ctx) {\n      return nil, errors.New("unauthorized: only accounts module is allowed to call this")\n   }\n   // Implement your authentication logic here\n   // ...\n   return &aa_interface_v1.MsgAuthenticateResponse{}, nil\n}\n\n// RegisterExecuteHandlers registers the execution handlers for the account.\nfunc (a Account) RegisterExecuteHandlers(builder *accountstd.ExecuteBuilder) {\n   accountstd.RegisterExecuteHandler(builder, a.SwapPubKey) // Other handlers\n   accountstd.RegisterExecuteHandler(builder, a.Authenticate) // Implements the Authentication interface\n}\n')),(0,i.kt)("h4",{id:"key-implementation-points"},"Key Implementation Points"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Sender Verification"),": Always verify that the sender is the x/accounts module. This prevents unauthorized accounts from triggering authentication."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Authentication Safety"),": Ensure your authentication mechanism is secure:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Prevent replay attacks by making it impossible to reuse the same action with the same signature.")))),(0,i.kt)("h5",{id:"implementation-example"},"Implementation example"),(0,i.kt)("p",null,"Please find an example ",(0,i.kt)("a",{parentName:"p",href:"./defaults/base/account.go"},"here"),"."),(0,i.kt)("h2",{id:"supporting-custom-accounts-in-the-xauth-grpc-server"},"Supporting Custom Accounts in the x/auth gRPC Server"),(0,i.kt)("h3",{id:"overview"},"Overview"),(0,i.kt)("p",null,"The x/auth module provides a mechanism for custom account types to be exposed via its ",(0,i.kt)("inlineCode",{parentName:"p"},"Account")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AccountInfo")," gRPC\nqueries. This feature is particularly useful for ensuring compatibility with existing wallets that have not yet integrated\nwith x/accounts but still need to parse account information post-migration."),(0,i.kt)("h3",{id:"implementation"},"Implementation"),(0,i.kt)("p",null,"To support this feature, your custom account type needs to implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"auth.QueryLegacyAccount")," handler. Here are some important points to consider:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Selective Implementation"),": This implementation is not required for every account type. It's only necessary for accounts you want to expose through the x/auth gRPC ",(0,i.kt)("inlineCode",{parentName:"li"},"Account")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"AccountInfo")," methods."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Flexible Response"),": The ",(0,i.kt)("inlineCode",{parentName:"li"},"info")," field in the ",(0,i.kt)("inlineCode",{parentName:"li"},"QueryLegacyAccountResponse")," is optional. If your custom account cannot be represented as a ",(0,i.kt)("inlineCode",{parentName:"li"},"BaseAccount"),", you can leave this field empty.")),(0,i.kt)("h3",{id:"example-implementation"},"Example Implementation"),(0,i.kt)("p",null,"A concrete example of implementation can be found in ",(0,i.kt)("inlineCode",{parentName:"p"},"defaults/base/account.go"),". Here's a simplified version:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (a Account) AuthRetroCompatibility(ctx context.Context, _ *authtypes.QueryLegacyAccount) (*authtypes.QueryLegacyAccountResponse, error) {\n    seq := a.GetSequence()\n    num := a.GetNumber()\n    address := a.GetAddress()\n    pubKey := a.GetPubKey()\n\n    baseAccount := &authtypes.BaseAccount{\n        AccountNumber: num,\n        Sequence:      seq,\n        Address:       address,\n    }\n\n    // Convert pubKey to Any type\n    pubKeyAny, err := gogotypes.NewAnyWithValue(pubKey)\n    if err != nil {\n        return nil, err\n    }\n    baseAccount.PubKey = pubKeyAny\n\n    // Convert the entire baseAccount to Any type\n    accountAny, err := gogotypes.NewAnyWithValue(baseAccount)\n    if err != nil {\n        return nil, err\n    }\n\n    return &authtypes.QueryLegacyAccountResponse{\n        Account: accountAny,\n        Info:    baseAccount,\n    }, nil\n}\n")),(0,i.kt)("h3",{id:"usage-notes"},"Usage Notes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Implement this handler only for account types you want to expose via x/auth gRPC methods."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"info")," field in the response can be nil if your account doesn't fit the ",(0,i.kt)("inlineCode",{parentName:"li"},"BaseAccount")," structure.")),(0,i.kt)("h2",{id:"genesis"},"Genesis"),(0,i.kt)("h3",{id:"creating-accounts-on-genesis"},"Creating accounts on genesis"),(0,i.kt)("p",null,"In order to create accounts at genesis, the ",(0,i.kt)("inlineCode",{parentName:"p"},"x/accounts")," module allows developers to provide\na list of genesis ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgInit")," messages that will be executed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"x/accounts")," genesis flow."),(0,i.kt)("p",null,"The init messages are generated offline. You can also use the following CLI command to generate the\njson messages: ",(0,i.kt)("inlineCode",{parentName:"p"},"simd accounts tx init [account type] [msg] --from me --genesis"),". This will generate\na jsonified init message wrapped in an x/accounts ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgInit"),"."),(0,i.kt)("p",null,"This follows the same initialization flow and rules that would happen if the chain is running.\nThe only concrete difference is that this is happening at the genesis block."),(0,i.kt)("p",null,"For example, given the following ",(0,i.kt)("inlineCode",{parentName:"p"},"genesis.json")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "app_state": {\n    "accounts": {\n      "init_account_msgs": [\n        {\n          "sender": "account_creator_address",\n          "account_type": "lockup",\n          "message": {\n            "@type": "cosmos.accounts.defaults.lockup.MsgInitLockupAccount",\n            "owner": "some_owner",\n            "end_time": "..",\n            "start_time": ".."\n          },\n          "funds": [\n            {\n              "denom": "stake",\n              "amount": "1000"\n            }\n          ]\n        }\n      ]\n    }\n  }\n}\n')),(0,i.kt)("p",null,"The accounts module will run the lockup account initialization message."))}d.isMDXComponent=!0}}]);