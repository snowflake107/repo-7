"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[44014],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),h=a,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return t?r.createElement(m,i(i({ref:n},d),{},{components:t})):r.createElement(m,i({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},23618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const o={},i="ADR 070: Un-Ordered Transaction Inclusion",s={unversionedId:"build/architecture/adr-070-unordered-account",id:"build/architecture/adr-070-unordered-account",title:"ADR 070: Un-Ordered Transaction Inclusion",description:"Changelog",source:"@site/docs/build/architecture/adr-070-unordered-account.md",sourceDirName:"build/architecture",slug:"/build/architecture/adr-070-unordered-account",permalink:"/main/build/architecture/adr-070-unordered-account",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"buildSidebar",previous:{title:"ADR 069: x/gov modularity, multiple choice and optimistic proposals",permalink:"/main/build/architecture/adr-069-gov-improvements"},next:{title:"ADR 070: Unordered Transactions",permalink:"/main/build/architecture/adr-070-unordered-transactions"}},l={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Transaction Format",id:"transaction-format",level:3},{value:"<code>DedupTxHashManager</code>",id:"deduptxhashmanager",level:3},{value:"Ante Handlers",id:"ante-handlers",level:3},{value:"<code>OnNewBlock</code>",id:"onnewblock",level:3},{value:"Start Up",id:"start-up",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"References",id:"references",level:2}],d={toc:c},u="wrapper";function p(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adr-070-un-ordered-transaction-inclusion"},"ADR 070: Un-Ordered Transaction Inclusion"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Dec 4, 2023: Initial Draft")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"ACCEPTED"),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,"We propose a way to do replay-attack protection without enforcing the order of\ntransactions, without requiring the use of nonces. In this way, we can support\nun-ordered transaction inclusion."),(0,a.kt)("h2",{id:"context"},"Context"),(0,a.kt)("p",null,"As of today, the nonce value (account sequence number) prevents replay-attack and\nensures the transactions from the same sender are included into blocks and executed\nin sequential order. However it makes it tricky to send many transactions from the\nsame sender concurrently in a reliable way. IBC relayer and crypto exchanges are\ntypical examples of such use cases."),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("p",null,"We propose to add a boolean field ",(0,a.kt)("inlineCode",{parentName:"p"},"unordered"),' to transaction body to mark "un-ordered"\ntransactions.'),(0,a.kt)("p",null,"Un-ordered transactions will bypass the nonce rules and follow the rules described\nbelow instead, in contrary, the default ordered transactions are not impacted by\nthis proposal, they'll follow the nonce rules the same as before."),(0,a.kt)("p",null,"When an un-ordered transaction is included into a block, the transaction hash is\nrecorded in a dictionary. New transactions are checked against this dictionary for\nduplicates, and to prevent the dictionary grow indefinitely, the transaction must\nspecify ",(0,a.kt)("inlineCode",{parentName:"p"},"timeout_height")," for expiration, so it's safe to removed it from the\ndictionary after it's expired."),(0,a.kt)("p",null,"The dictionary can be simply implemented as an in-memory golang map, a preliminary\nanalysis shows that the memory consumption won't be too big, for example ",(0,a.kt)("inlineCode",{parentName:"p"},"32M = 32 * 1024 * 1024"),"\ncan support 1024 blocks where each block contains 1024 unordered transactions. For\nsafety, we should limit the range of ",(0,a.kt)("inlineCode",{parentName:"p"},"timeout_height")," to prevent very long expiration,\nand limit the size of the dictionary."),(0,a.kt)("h3",{id:"transaction-format"},"Transaction Format"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},"message TxBody {\n  ...\n\n  bool unordered = 4; \n}\n")),(0,a.kt)("h3",{id:"deduptxhashmanager"},(0,a.kt)("inlineCode",{parentName:"h3"},"DedupTxHashManager")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},"const PurgeLoopSleepMS = 500\n\n// DedupTxHashManager contains the tx hash dictionary for duplicates checking,\n// and expire them when block number progresses.\ntype DedupTxHashManager struct {\n  mutex sync.RWMutex\n  // tx hash -> expire block number\n  // for duplicates checking and expiration\n  hashes map[TxHash]uint64\n  // channel to receive latest block numbers\n  blockCh chan uint64\n}\n\nfunc NewDedupTxHashManager() *DedupTxHashManager {\n  m := &DedupTxHashManager{\n    hashes: make(map[TxHash]uint64),\n    blockCh: make(ch *uint64, 16),\n  }\n  go m.purgeLoop()\n  return m\n}\n\nfunc (dtm *DedupTxHashManager) Close() error {\n  close(dtm.blockCh)\n  dtm.blockCh = nil\n  return nil\n}\n\nfunc (dtm *DedupTxHashManager) Contains(hash TxHash) (ok bool) {\n  dtm.mutex.RLock()\n  defer dtm.mutex.RUnlock()\n\n  _, ok = dtm.hashes[hash]\n  return\n}\n\nfunc (dtm *DedupTxHashManager) Size() int {\n  dtm.mutex.RLock()\n  defer dtm.mutex.RUnlock()\n\n  return len(dtm.hashes)\n}\n\nfunc (dtm *DedupTxHashManager) Add(hash TxHash, expire uint64) (ok bool) {\n  dtm.mutex.Lock()\n  defer dtm.mutex.Unlock()\n\n  dtm.hashes[hash] = expire\n  return\n}\n\n// OnNewBlock send the latest block number to the background purge loop,\n// it should be called in abci commit event.\nfunc (dtm *DedupTxHashManager) OnNewBlock(blockNumber uint64) {\n  dtm.blockCh <- &blockNumber\n}\n\n// purgeLoop removes expired tx hashes at background\nfunc (dtm *DedupTxHashManager) purgeLoop() error {\n  for {\n    blocks := channelBatchRecv(dtm.blockCh)\n    if len(blocks) == 0 {\n      // channel closed\n      break\n    }\n    \n    latest := *blocks[len(blocks)-1]\n    hashes := dtm.expired(latest)\n    if len(hashes) > 0 {\n      dtm.purge(hashes)\n    }\n    \n    // avoid burning cpu in catching up phase\n    time.Sleep(PurgeLoopSleepMS * time.Millisecond)\n  }\n}\n\n// expired find out expired tx hashes based on latest block number\nfunc (dtm *DedupTxHashManager) expired(block uint64) []TxHash {\n  dtm.mutex.RLock()\n  defer dtm.mutex.RUnlock()\n\n  var result []TxHash\n  for h, expire := range dtm.hashes {\n    if block > expire {\n      result = append(result, h)\n    }\n  }\n  return result\n}\n\nfunc (dtm *DedupTxHashManager) purge(hashes []TxHash) {\n  dtm.mutex.Lock()\n  defer dtm.mutex.Unlock()\n\n  for _, hash := range hashes {\n    delete(dtm.hashes, hash)\n  }\n}\n\n// channelBatchRecv try to exhaust the channel buffer when it's not empty,\n// and block when it's empty.\nfunc channelBatchRecv[T any](ch <-chan *T) []*T {\n    item := <-ch  // block if channel is empty\n    if item == nil {\n        // channel is closed\n        return nil\n    }\n\n    remaining := len(ch)\n    result := make([]*T, 0, remaining+1)\n    result = append(result, item)\n    for i := 0; i < remaining; i++ {\n        result = append(result, <-ch)\n    }\n\n    return result\n}\n")),(0,a.kt)("h3",{id:"ante-handlers"},"Ante Handlers"),(0,a.kt)("p",null,"Bypass the nonce decorator for un-ordered transactions."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},"func (isd IncrementSequenceDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (sdk.Context, error) {\n  if tx.UnOrdered() {\n    return next(ctx, tx, simulate)\n  }\n\n  // the previous logic\n}\n")),(0,a.kt)("p",null,"A decorator for the new logic."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type TxHash [32]byte\n\nconst (\n  // MaxUnOrderedTTL defines the maximum ttl an un-order tx can set\n  MaxUnOrderedTTL = 1024\n)\n\ntype DedupTxDecorator struct {\n  m *DedupTxHashManager\n}\n\nfunc (dtd *DedupTxDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (sdk.Context, error) {\n  // only apply to un-ordered transactions\n  if !tx.UnOrdered() {\n    return next(ctx, tx, simulate)\n  }\n\n  if tx.TimeoutHeight() == 0 {\n    return nil, errorsmod.Wrap(sdkerrors.ErrLogic, "unordered tx must set timeout-height")\n  }\n\n  if tx.TimeoutHeight() > ctx.BlockHeight() + MaxUnOrderedTTL {\n    return nil, errorsmod.Wrapf(sdkerrors.ErrLogic, "unordered tx ttl exceeds %d", MaxUnOrderedTTL)\n  }\n\n  // check for duplicates\n  if dtd.m.Contains(tx.Hash()) {\n    return nil, errorsmod.Wrap(sdkerrors.ErrLogic, "tx is duplicated")\n  }\n\n  if !ctx.IsCheckTx() {\n    // a new tx included in the block, add the hash to the dictionary\n    dtd.m.Add(tx.Hash(), tx.TimeoutHeight())\n  }\n\n  return next(ctx, tx, simulate)\n}\n')),(0,a.kt)("h3",{id:"onnewblock"},(0,a.kt)("inlineCode",{parentName:"h3"},"OnNewBlock")),(0,a.kt)("p",null,"Wire the ",(0,a.kt)("inlineCode",{parentName:"p"},"OnNewBlock")," method of ",(0,a.kt)("inlineCode",{parentName:"p"},"DedupTxHashManager")," into the BaseApp's ABCI Commit event."),(0,a.kt)("h3",{id:"start-up"},"Start Up"),(0,a.kt)("p",null,"On start up, the node needs to re-fill the tx hash dictionary of ",(0,a.kt)("inlineCode",{parentName:"p"},"DedupTxHashManager"),"\nby scanning ",(0,a.kt)("inlineCode",{parentName:"p"},"MaxUnOrderedTTL")," number of historical blocks for existing un-expired\nun-ordered transactions."),(0,a.kt)("p",null,"An alternative design is to store the tx hash dictionary in kv store, then no need\nto warm up on start up."),(0,a.kt)("h2",{id:"consequences"},"Consequences"),(0,a.kt)("h3",{id:"positive"},"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Support un-ordered and concurrent transaction inclusion.")),(0,a.kt)("h3",{id:"negative"},"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Start up overhead to scan historical blocks.")),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/issues/13009"},"https://github.com/cosmos/cosmos-sdk/issues/13009"))))}p.isMDXComponent=!0}}]);