"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[5040],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(n),h=i,u=m["".concat(l,".").concat(h)]||m[h]||c[h]||a;return n?o.createElement(u,r(r({ref:t},p),{},{components:n})):o.createElement(u,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,r[1]=s;for(var d=2;d<a;d++)r[d]=n[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},22493:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var o=n(87462),i=(n(67294),n(3905));const a={},r="ADR 054: Semver Compatible SDK Modules",s={unversionedId:"build/architecture/adr-054-semver-compatible-modules",id:"build/architecture/adr-054-semver-compatible-modules",title:"ADR 054: Semver Compatible SDK Modules",description:"Changelog",source:"@site/docs/build/architecture/adr-054-semver-compatible-modules.md",sourceDirName:"build/architecture",slug:"/build/architecture/adr-054-semver-compatible-modules",permalink:"/main/build/architecture/adr-054-semver-compatible-modules",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"buildSidebar",previous:{title:"ADR 053: Go Module Refactoring",permalink:"/main/build/architecture/adr-053-go-module-refactoring"},next:{title:"ADR 055: ORM",permalink:"/main/build/architecture/adr-055-orm"}},l={},d=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Problem 1: Semantic Import Versioning Compatibility",id:"problem-1-semantic-import-versioning-compatibility",level:3},{value:"Scenario A: Backward Compatibility: Newer Foo, Older Bar",id:"scenario-a-backward-compatibility-newer-foo-older-bar",level:4},{value:"Scenario B: Forward Compatibility: Older Foo, Newer Bar",id:"scenario-b-forward-compatibility-older-foo-newer-bar",level:4},{value:"Naive Mitigation",id:"naive-mitigation",level:4},{value:"Problem 2: Circular dependencies",id:"problem-2-circular-dependencies",level:3},{value:"Problem 3: Handling Minor Version Incompatibilities",id:"problem-3-handling-minor-version-incompatibilities",level:3},{value:"Solutions",id:"solutions",level:2},{value:"Approach A) Separate API and State Machine Modules",id:"approach-a-separate-api-and-state-machine-modules",level:3},{value:"Migrate all interface methods on API types to handlers",id:"migrate-all-interface-methods-on-api-types-to-handlers",level:4},{value:"Pinned FileDescriptor&#39;s",id:"pinned-filedescriptors",level:4},{value:"Potential limitations to generated code",id:"potential-limitations-to-generated-code",level:4},{value:"Minor Version Incompatibilities",id:"minor-version-incompatibilities",level:4},{value:"No New Fields in Existing Protobuf Messages",id:"no-new-fields-in-existing-protobuf-messages",level:4},{value:"Approach B) Changes to Generated Code to a Getter/Setter API",id:"approach-b-changes-to-generated-code-to-a-gettersetter-api",level:3},{value:"Approach C) Don&#39;t address these issues",id:"approach-c-dont-address-these-issues",level:3},{value:"Approach D) Avoid protobuf generated code in public APIs",id:"approach-d-avoid-protobuf-generated-code-in-public-apis",level:3},{value:"Approach E) Use Structural Typing in Inter-module APIs, Avoid New Fields on Messages",id:"approach-e-use-structural-typing-in-inter-module-apis-avoid-new-fields-on-messages",level:3},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"References",id:"references",level:2}],p={toc:d},m="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adr-054-semver-compatible-sdk-modules"},"ADR 054: Semver Compatible SDK Modules"),(0,i.kt)("h2",{id:"changelog"},"Changelog"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-04-27: First draft"),(0,i.kt)("li",{parentName:"ul"},"2024-07-21: Second draft")),(0,i.kt)("h2",{id:"status"},"Status"),(0,i.kt)("p",null,"DRAFT"),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"In order to move the Cosmos SDK to a system of decoupled semantically versioned\nmodules which can be composed in different combinations (ex. staking v3 with\nbank v1 and distribution v2), we need to reassess how we organize the API surface\nof modules to avoid problems with go semantic import versioning and\ncircular dependencies. This ADR explores various approaches we can take to\naddressing these issues."),(0,i.kt)("h2",{id:"context"},"Context"),(0,i.kt)("p",null,"There has been ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/discussions/10162"},"a fair amount of desire"),"\nin the community for semantic versioning in the SDK and there has been significant\nmovement to splitting SDK modules into ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/issues/11899"},"standalone go modules"),".\nBoth of these will ideally allow the ecosystem to move faster because we won't\nbe waiting for all dependencies to update synchronously. For instance, we could\nhave 3 versions of the core SDK compatible with the latest 2 releases of\nCosmWasm as well as 4 different versions of staking . This sort of setup would\nallow early adopters to aggressively integrate new versions, while allowing\nmore conservative users to be selective about which versions they're ready for."),(0,i.kt)("p",null,"In order to achieve this, we need to solve the following problems:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"because of the way ",(0,i.kt)("a",{parentName:"li",href:"https://research.swtch.com/vgo-import"},"go semantic import versioning")," (SIV)\nworks, moving to SIV naively will actually make it harder to achieve these goals"),(0,i.kt)("li",{parentName:"ol"},"circular dependencies between modules need to be broken to actually release\nmany modules in the SDK independently"),(0,i.kt)("li",{parentName:"ol"},"pernicious minor version incompatibilities introduced through correctly\n",(0,i.kt)("a",{parentName:"li",href:"https://protobuf.dev/programming-guides/proto3/#updating"},"evolving protobuf schemas"),"\nwithout correct ",(0,i.kt)("a",{parentName:"li",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"))),(0,i.kt)("p",null,"Note that all the following discussion assumes that the proto file versioning and state machine versioning of a module\nare distinct in that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"proto files are maintained in a non-breaking way (using something\nlike ",(0,i.kt)("a",{parentName:"li",href:"https://docs.buf.build/breaking/overview"},"buf breaking"),"\nto ensure all changes are backwards compatible)"),(0,i.kt)("li",{parentName:"ul"},"proto file versions get bumped much less frequently, i.e. we might maintain ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmos.bank.v1")," through many versions\nof the bank module state machine"),(0,i.kt)("li",{parentName:"ul"},"state machine breaking changes are more common and ideally this is what we'd want to semantically version with\ngo modules, ex. ",(0,i.kt)("inlineCode",{parentName:"li"},"x/bank/v2"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"x/bank/v3"),", etc.")),(0,i.kt)("h3",{id:"problem-1-semantic-import-versioning-compatibility"},"Problem 1: Semantic Import Versioning Compatibility"),(0,i.kt)("p",null,"Consider we have a module ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," which defines the following ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," and that we've released its state\nmachine in go module ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"package foo.v1;\n\nmessage MsgDoSomething {\n  string sender = 1;\n  uint64 amount = 2;\n}\n\nservice Msg {\n  DoSomething(MsgDoSomething) returns (MsgDoSomethingResponse);\n}\n")),(0,i.kt)("p",null,"Now consider that we make a revision to this module and add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," field to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," and also\nadd a new validation rule on ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," requiring it to be non-zero, and that following go semantic versioning we\nrelease the next state machine version of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"// Revision 1\npackage foo.v1;\n\nmessage MsgDoSomething {\n  string sender = 1;\n  \n  // amount must be a non-zero integer.\n  uint64 amount = 2;\n  \n  // condition is an optional condition on doing the thing.\n  //\n  // Since: Revision 1\n  Condition condition = 3;\n}\n")),(0,i.kt)("p",null,"Approaching this naively, we would generate the protobuf types for the initial\nversion of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types")," and we would generate the protobuf\ntypes for the second version in ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types"),"."),(0,i.kt)("p",null,"Now let's say we have a module ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," which talks to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," using this keeper\ninterface which ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," provides:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type FooKeeper interface {\n    DoSomething(MsgDoSomething) error\n}\n")),(0,i.kt)("h4",{id:"scenario-a-backward-compatibility-newer-foo-older-bar"},"Scenario A: Backward Compatibility: Newer Foo, Older Bar"),(0,i.kt)("p",null,"Imagine we have a chain which uses both ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," and wants to upgrade to\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),", but the ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," module has not upgraded to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),"."),(0,i.kt)("p",null,"In this case, the chain will not be able to upgrade to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," until ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"\nhas upgraded its references to ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types.MsgDoSomething")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types.MsgDoSomething"),"."),(0,i.kt)("p",null,"Even if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"'s usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," has not changed at all, the upgrade\nwill be impossible without this change because ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types.MsgDoSomething"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types.MsgDoSomething")," are fundamentally different\nincompatible structs in the go type system."),(0,i.kt)("h4",{id:"scenario-b-forward-compatibility-older-foo-newer-bar"},"Scenario B: Forward Compatibility: Older Foo, Newer Bar"),(0,i.kt)("p",null,"Now let's consider the reverse scenario, where ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," upgrades to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),"\nby changing the ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types.MsgDoSomething"),"\nand releases that as ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," with some other changes that a chain wants.\nThe chain, however, has decided that it thinks the changes in ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," are too\nrisky and that it'd prefer to stay on the initial version of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,i.kt)("p",null,"In this scenario, it is impossible to upgrade to ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," without upgrading\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," even if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," would have worked 100% fine with ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," other\nthan changing the import path to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," (meaning that ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2"),"\ndoesn't actually use any new features of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),")."),(0,i.kt)("p",null,"Now because of the way go semantic import versioning works, we are locked\ninto either using ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," OR ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2"),". We cannot have\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," OR ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," + ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),". The go type system doesn't allow this\neven if both versions of these modules are otherwise compatible with each\nother."),(0,i.kt)("h4",{id:"naive-mitigation"},"Naive Mitigation"),(0,i.kt)("p",null,"A naive approach to fixing this would be to not regenerate the protobuf types\nin ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/v2/types")," but instead just update ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types"),"\nto reflect the changes needed for ",(0,i.kt)("inlineCode",{parentName:"p"},"v2")," (adding ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," and requiring\n",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," to be non-zero). Then we could release a patch of ",(0,i.kt)("inlineCode",{parentName:"p"},"example.com/foo/types"),"\nwith this update and use that for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),". But this change is state machine\nbreaking for ",(0,i.kt)("inlineCode",{parentName:"p"},"v1"),". It requires changing the ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateBasic")," method to reject\nthe case where ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," is zero, and it adds the ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," field which\nshould be rejected based\non ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"ADR 020 unknown field filtering"),".\nSo adding these changes as a patch on ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," is actually incorrect based on semantic\nversioning. Chains that want to stay on ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," should not\nbe importing these changes because they are incorrect for ",(0,i.kt)("inlineCode",{parentName:"p"},"v1.")),(0,i.kt)("h3",{id:"problem-2-circular-dependencies"},"Problem 2: Circular dependencies"),(0,i.kt)("p",null,"None of the above approaches allow ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," to be separate modules\nif for some reason ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," depend on each other in different ways.\nFor instance, we can't have ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," import ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/types")," while ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," imports\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/types"),"."),(0,i.kt)("p",null,"We have several cases of circular module dependencies in the SDK\n(ex. staking, distribution and slashing) that are legitimate from a state machine\nperspective. Without separating the API types out somehow, there would be\nno way to independently semantically version these modules without some other\nmitigation."),(0,i.kt)("h3",{id:"problem-3-handling-minor-version-incompatibilities"},"Problem 3: Handling Minor Version Incompatibilities"),(0,i.kt)("p",null,"Imagine that we solve the first two problems but now have a scenario where\n",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," wants the option to use ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething.condition")," which only ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),"\nsupports. If ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," works with ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," and sets ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," to some non-nil\nvalue, then ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," will silently ignore this field resulting in a silent logic\npossibly dangerous logic error. If ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," were able to check whether ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," was\non ",(0,i.kt)("inlineCode",{parentName:"p"},"v1")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"v2")," and dynamically, it could choose to only use ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," when\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," is available. Even if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/v2")," were able to perform this check, however,\nhow do we know that it is always performing the check properly. Without\nsome sort of\nframework-level ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),",\nit is hard to know whether these pernicious hard to detect bugs are getting into\nour app and a client-server layer such as ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033: Inter-Module Communication"),"\nmay be needed to do this."),(0,i.kt)("h2",{id:"solutions"},"Solutions"),(0,i.kt)("h3",{id:"approach-a-separate-api-and-state-machine-modules"},"Approach A) Separate API and State Machine Modules"),(0,i.kt)("p",null,"One solution (first proposed in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/discussions/10582"},"https://github.com/cosmos/cosmos-sdk/discussions/10582"),") is to isolate all protobuf\ngenerated code into a separate module\nfrom the state machine module. This would mean that we could have state machine\ngo modules ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," which could use a types or API go module say\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api"),". This ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api")," go module would be perpetually on ",(0,i.kt)("inlineCode",{parentName:"p"},"v1.x")," and only\naccept non-breaking changes. This would then allow other modules to be\ncompatible with either ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," as long as the inter-module API only\ndepends on the types in ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api"),". It would also allow modules ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"\nto depend on each other in that both of them could depend on ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"bar/api")," without ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," directly depending on ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," and vice versa."),(0,i.kt)("p",null,"This is similar to the naive mitigation described above except that it separates\nthe types into separate go modules which in and of itself could be used to\nbreak circular module dependencies. It has the same problems as the naive solution,\notherwise, which we could rectify by:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"removing all state machine breaking code from the API module (ex. ",(0,i.kt)("inlineCode",{parentName:"li"},"ValidateBasic")," and any other interface methods)"),(0,i.kt)("li",{parentName:"ol"},"embedding the correct file descriptors for unknown field filtering in the binary")),(0,i.kt)("h4",{id:"migrate-all-interface-methods-on-api-types-to-handlers"},"Migrate all interface methods on API types to handlers"),(0,i.kt)("p",null,"To solve 1), we need to remove all interface implementations from generated\ntypes and instead use a handler approach which essentially means that given\na type ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", we have some sort of resolver which allows us to resolve interface\nimplementations for that type (ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"sdk.Msg")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"authz.Authorization"),"). For\nexample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (k Keeper) DoSomething(msg MsgDoSomething) error {\n    var validateBasicHandler ValidateBasicHandler\n    err := k.resolver.Resolve(&validateBasicHandler, msg)\n    if err != nil {\n        return err\n    }   \n    \n    err = validateBasicHandler.ValidateBasic()\n    ...\n}\n")),(0,i.kt)("p",null,"In the case of some methods on ",(0,i.kt)("inlineCode",{parentName:"p"},"sdk.Msg"),", we could replace them with declarative\nannotations. For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"GetSigners")," can already be replaced by the protobuf\nannotation ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmos.msg.v1.signer"),". In the future, we may consider some sort\nof protobuf validation framework (like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bufbuild/protoc-gen-validate"},"https://github.com/bufbuild/protoc-gen-validate"),"\nbut more Cosmos-specific) to replace ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateBasic"),"."),(0,i.kt)("h4",{id:"pinned-filedescriptors"},"Pinned FileDescriptor's"),(0,i.kt)("p",null,"To solve 2), state machine modules must be able to specify what the version of\nthe protobuf files was that they were built against. For instance if the API\nmodule for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," upgrades to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),", the original ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," module still needs\na copy of the original protobuf files it was built with so that ADR 020\nunknown field filtering will reject ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," when ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," is\nset."),(0,i.kt)("p",null,"The simplest way to do this may be to embed the protobuf ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s into\nthe module itself so that these ",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s are used at runtime rather\nthan the ones that are built into the ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/api")," which may be different. Using\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.buf.build/build/usage#output-format"},"buf build"),", ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/embed"},"go embed"),",\nand a build script we can probably come up with a solution for embedding\n",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s into modules that is fairly straightforward."),(0,i.kt)("h4",{id:"potential-limitations-to-generated-code"},"Potential limitations to generated code"),(0,i.kt)("p",null,"One challenge with this approach is that it places heavy restrictions on what\ncan go in API modules and requires that most of this is state machine breaking.\nAll or most of the code in the API module would be generated from protobuf\nfiles, so we can probably control this with how code generation is done, but\nit is a risk to be aware of."),(0,i.kt)("p",null,"For instance, we do code generation for the ORM that in the future could\ncontain optimizations that are state machine breaking. We\nwould either need to ensure very carefully that the optimizations aren't\nactually state machine breaking in generated code or separate this generated code\nout from the API module into the state machine module. Both of these mitigations\nare potentially viable but the API module approach does require an extra level\nof care to avoid these sorts of issues."),(0,i.kt)("h4",{id:"minor-version-incompatibilities"},"Minor Version Incompatibilities"),(0,i.kt)("p",null,"This approach in and of itself does little to address any potential minor\nversion incompatibilities and the\nrequisite ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),".\nLikely some sort of client-server routing layer which does this check such as\n",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033: Inter-Module communication"),"\nis required to make sure that this is done properly. We could then allow\nmodules to perform a runtime check given a ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgClient"),", ex:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (k Keeper) CallFoo() error {\n    if k.interModuleClient.MinorRevision(k.fooMsgClient) >= 2 {\n        k.fooMsgClient.DoSomething(&MsgDoSomething{Condition: ...})\n    } else {\n        ...\n    }\n}\n")),(0,i.kt)("p",null,"To do the unknown field filtering itself, the ADR 033 router would need to use\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect"},"protoreflect API"),"\nto ensure that no fields unknown to the receiving module are set. This could\nresult in an undesirable performance hit depending on how complex this logic is."),(0,i.kt)("h4",{id:"no-new-fields-in-existing-protobuf-messages"},"No New Fields in Existing Protobuf Messages"),(0,i.kt)("p",null,"An alternative to addressing minor version incompatibilities as described above is disallowing new fields in existing protobuf messages. While this is more restrictive, it simplifies versioning and eliminates the need for runtime unknown field checking. In addition, this approach would simplify cross language communication with the proposed ",(0,i.kt)("a",{parentName:"p",href:"/main/build/rfc/rfc-002-zero-copy-encoding"},"RFC 002: Zero Copy Encoding"),". So, while it is rather restrictive, it has gained a fair amount of support."),(0,i.kt)("p",null,"Although disallowing new fields may seem overly restrictive, there is a straightforward way to work around it using protobuf ",(0,i.kt)("inlineCode",{parentName:"p"},"oneof"),"s. Because ",(0,i.kt)("inlineCode",{parentName:"p"},"oneof")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," cases must get processed through a ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," statement, adding new cases is not problematic because any unknown cases can be handled by a ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," clause. The router layer wouldn't need to do unknown field filtering for these because the ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," statement is a native way to do this. If we needed to add new fields to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," from above and retain the possibility of adding more new fields in the future, we could do something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgDoSomethingWithOptions {\n  string sender = 1;\n  uint64 amount = 2;\n  repeated MsgDoSomethingOption options = 3;\n}\n\nmessage MsgDoSomethingOption {\n  oneof option {\n    Condition condition = 1;\n  }\n}\n")),(0,i.kt)("p",null,"New ",(0,i.kt)("inlineCode",{parentName:"p"},"oneof")," cases can be added to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomethingOption")," and this has a similar effect as adding new fields to ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomethingWithOptions")," but no new fields are needed. A similar strategy is recommended for adding variadic options to golang functions in ",(0,i.kt)("a",{parentName:"p",href:"https://go.dev/blog/module-compatibility"},"https://go.dev/blog/module-compatibility")," and expanded upon in ",(0,i.kt)("a",{parentName:"p",href:"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html"},"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html"),"."),(0,i.kt)("h3",{id:"approach-b-changes-to-generated-code-to-a-gettersetter-api"},"Approach B) Changes to Generated Code to a Getter/Setter API"),(0,i.kt)("p",null,"An alternate approach to solving the versioning problem is to change how protobuf code is generated and move modules\nmostly or completely in the direction of inter-module communication as described\nin ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"),".\nIn this paradigm, a module could generate all the types it needs internally - including the API types of other modules -\nand talk to other modules via a client-server boundary. For instance, if ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," needs to talk to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", it could\ngenerate its own version of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/internal/foo/v1.MsgDoSomething")," and just pass this to the\ninter-module router which would somehow convert it to the version which foo needs (ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/internal.MsgDoSomething"),")."),(0,i.kt)("p",null,"Currently, two generated structs for the same protobuf type cannot exist in the same go binary without special\nbuild flags (see ",(0,i.kt)("a",{parentName:"p",href:"https://protobuf.dev/reference/go/faq/#fix-namespace-conflict"},"https://protobuf.dev/reference/go/faq/#fix-namespace-conflict"),").\nA relatively simple mitigation to this issue would be to set up the protobuf code to not register protobuf types\nglobally if they are generated in an ",(0,i.kt)("inlineCode",{parentName:"p"},"internal/")," package. This will require modules to register their types manually\nwith the app-level level protobuf registry, this is similar to what modules already do with the ",(0,i.kt)("inlineCode",{parentName:"p"},"InterfaceRegistry"),"\nand amino codec."),(0,i.kt)("p",null,"If modules ",(0,i.kt)("em",{parentName:"p"},"only")," do ADR 033 message passing then a naive and non-performant solution for\nconverting ",(0,i.kt)("inlineCode",{parentName:"p"},"bar/internal/foo/v1.MsgDoSomething"),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/internal.MsgDoSomething")," would be marshaling and unmarshaling in the ADR 033 router. This would break down if\nwe needed to expose protobuf types in ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," interfaces because the whole point is to try to keep these types\n",(0,i.kt)("inlineCode",{parentName:"p"},"internal/")," so that we don't end up with all the import version incompatibilities we've described above. However,\nbecause of the issue with minor version incompatibilities and the need\nfor ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),",\nsticking with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," paradigm instead of ADR 033 may be unviable to begin with."),(0,i.kt)("p",null,"A more performant solution (that could maybe be adapted to work with ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," interfaces) would be to only expose\ngetters and setters for generated types and internally store data in memory buffers which could be passed from\none implementation to another in a zero-copy way."),(0,i.kt)("p",null,"For example, imagine this protobuf API with only getters and setters is exposed for ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type MsgSend interface {\n    proto.Message\n    GetFromAddress() string\n    GetToAddress() string\n    GetAmount() []v1beta1.Coin\n    SetFromAddress(string)\n    SetToAddress(string)\n    SetAmount([]v1beta1.Coin)\n}\n\nfunc NewMsgSend() MsgSend { return &msgSendImpl{memoryBuffers: ...} }\n")),(0,i.kt)("p",null,"Under the hood, ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend")," could be implemented based on some raw memory buffer in the same way\nthat ",(0,i.kt)("a",{parentName:"p",href:"https://capnproto.org"},"Cap'n Proto"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://google.github.io/flatbuffers/"},"FlatBuffers")," so that we could convert between one version of ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend"),"\nand another without serialization (i.e. zero-copy). This approach would have the added benefits of allowing zero-copy\nmessage passing to modules written in other languages such as Rust and accessed through a VM or FFI. It could also make\nunknown field filtering in inter-module communication simpler if we require that all new fields are added in sequential\norder, ex. just checking that no field ",(0,i.kt)("inlineCode",{parentName:"p"},"> 5")," is set."),(0,i.kt)("p",null,"Also, we wouldn't have any issues with state machine breaking code on generated types because all the generated\ncode used in the state machine would actually live in the state machine module itself. Depending on how interface\ntypes and protobuf ",(0,i.kt)("inlineCode",{parentName:"p"},"Any"),"s are used in other languages, however, it may still be desirable to take the handler\napproach described in approach A. Either way, types implementing interfaces would still need to be registered\nwith an ",(0,i.kt)("inlineCode",{parentName:"p"},"InterfaceRegistry")," as they are now because there would be no way to retrieve them via the global registry."),(0,i.kt)("p",null,"In order to simplify access to other modules using ADR 033, a public API module (maybe even one\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.buf.build/bsr/remote-generation/go"},"remotely generated by Buf"),") could be used by client modules instead\nof requiring to generate all client types internally."),(0,i.kt)("p",null,"The big downsides of this approach are that it requires big changes to how people use protobuf types and would be a\nsubstantial rewrite of the protobuf code generator. This new generated code, however, could still be made compatible\nwith\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect"},(0,i.kt)("inlineCode",{parentName:"a"},"google.golang.org/protobuf/reflect/protoreflect")),"\nAPI in order to work with all standard golang protobuf tooling."),(0,i.kt)("p",null,"It is possible that the naive approach of marshaling/unmarshaling in the ADR 033 router is an acceptable intermediate\nsolution if the changes to the code generator are seen as too complex. However, since all modules would likely need\nto migrate to ADR 033 anyway with this approach, it might be better to do this all at once."),(0,i.kt)("h3",{id:"approach-c-dont-address-these-issues"},"Approach C) Don't address these issues"),(0,i.kt)("p",null,"If the above solutions are seen as too complex, we can also decide not to do anything explicit to enable better module\nversion compatibility, and break circular dependencies."),(0,i.kt)("p",null,"In this case, when developers are confronted with the issues described above they can require dependencies to update in\nsync (what we do now) or attempt some ad-hoc potentially hacky solution."),(0,i.kt)("p",null,"One approach is to ditch go semantic import versioning (SIV) altogether. Some people have commented that go's SIV\n(i.e. changing the import path to ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v3"),", etc.) is too restrictive and that it should be optional. The\ngolang maintainers disagree and only officially support semantic import versioning. We could, however, take the\ncontrarian perspective and get more flexibility by using 0.x-based versioning basically forever."),(0,i.kt)("p",null,"Module version compatibility could then be achieved using go.mod replace directives to pin dependencies to specific\ncompatible 0.x versions. For instance if we knew ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," 0.2 and 0.3 were both compatible with ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," 0.3 and 0.4, we\ncould use replace directives in our go.mod to stick to the versions of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," we want. This would work as\nlong as the authors of ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," avoid incompatible breaking changes between these modules."),(0,i.kt)("p",null,"Or, if developers choose to use semantic import versioning, they can attempt the naive solution described above\nand would also need to use special tags and replace directives to make sure that modules are pinned to the correct\nversions."),(0,i.kt)("p",null,"Note, however, that all of these ad-hoc approaches, would be vulnerable to the minor version compatibility issues\ndescribed above unless ",(0,i.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding#unknown-field-filtering"},"unknown field filtering"),"\nis properly addressed."),(0,i.kt)("h3",{id:"approach-d-avoid-protobuf-generated-code-in-public-apis"},"Approach D) Avoid protobuf generated code in public APIs"),(0,i.kt)("p",null,"An alternative approach would be to avoid protobuf generated code in public module APIs. This would help avoid the\ndiscrepancy between state machine versions and client API versions at the module to module boundaries. It would mean\nthat we wouldn't do inter-module message passing based on ADR 033, but rather stick to the existing keeper approach\nand take it one step further by avoiding any protobuf generated code in the keeper interface methods."),(0,i.kt)("p",null,"Using this approach, our ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.Keeper.DoSomething")," method wouldn't have the generated ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgDoSomething")," struct (which\ncomes from the protobuf API), but instead positional parameters. Then in order for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v2")," to support the ",(0,i.kt)("inlineCode",{parentName:"p"},"foo/v1"),"\nkeeper it would simply need to implement both the v1 and v2 keeper APIs. The ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomething")," method in v2 could have the\nadditional ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," parameter, but this wouldn't be present in v1 at all so there would be no danger of a client\naccidentally setting this when it isn't available. "),(0,i.kt)("p",null,"So this approach would avoid the challenge around minor version incompatibilities because the existing module keeper\nAPI would not get new fields when they are added to protobuf files."),(0,i.kt)("p",null,"Taking this approach, however, would likely require making all protobuf generated code internal in order to prevent\nit from leaking into the keeper API. This means we would still need to modify the protobuf code generator to not\nregister ",(0,i.kt)("inlineCode",{parentName:"p"},"internal/")," code with the global registry, and we would still need to manually register protobuf\n",(0,i.kt)("inlineCode",{parentName:"p"},"FileDescriptor"),"s (this is probably true in all scenarios). It may, however, be possible to avoid needing to refactor\ninterface methods on generated types to handlers."),(0,i.kt)("p",null,"Also, this approach doesn't address what would be done in scenarios where modules still want to use the message router.\nEither way, we probably still want a way to pass messages from one module to another router safely even if it's just for\nuse cases like ",(0,i.kt)("inlineCode",{parentName:"p"},"x/gov"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"x/authz"),", CosmWasm, etc. That would still require most of the things outlined in approach (B),\nalthough we could advise modules to prefer keepers for communicating with other modules."),(0,i.kt)("p",null,"The biggest downside of this approach is probably that it requires a strict refactoring of keeper interfaces to avoid\ngenerated code leaking into the API. This may result in cases where we need to duplicate types that are already defined\nin proto files and then write methods for converting between the golang and protobuf version. This may end up in a lot\nof unnecessary boilerplate and that may discourage modules from actually adopting it and achieving effective version\ncompatibility. Approaches (A) and (B), although heavy handed initially, aim to provide a system which once adopted\nmore or less gives the developer version compatibility for free with minimal boilerplate. Approach (D) may not be able\nto provide such a straightforward system since it requires a golang API to be defined alongside a protobuf API in a\nway that requires duplication and differing sets of design principles (protobuf APIs encourage additive changes\nwhile golang APIs would forbid it)."),(0,i.kt)("p",null,"Other downsides to this approach are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"no clear roadmap to supporting modules in other languages like Rust"),(0,i.kt)("li",{parentName:"ul"},"doesn't get us any closer to proper object capability security (one of the goals of ADR 033)"),(0,i.kt)("li",{parentName:"ul"},"ADR 033 needs to be done properly anyway for the set of use cases which do need it")),(0,i.kt)("h3",{id:"approach-e-use-structural-typing-in-inter-module-apis-avoid-new-fields-on-messages"},"Approach E) Use Structural Typing in Inter-module APIs, Avoid New Fields on Messages"),(0,i.kt)("p",null,"The current non-router based approach for inter-module communication is for a module to define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Keeper")," interface and for a consumer module to define an expected keeper interface with a subset of the keeper's methods. Such an interface can allow one module to avoid a direct dependency on another module if no concrete types need to be imported from the other module. For instance, if we had a method ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomething(context.Context, string, uint64)")," as in ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.v1"),", then a module calling ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomething")," would not need to import ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," directly. If, however, we had a struct parameter such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Condition")," and the new method were ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomethingV2(context.Context, string, uint64, foo.Condition)")," then a calling module would generally need to import foo just to get a reference to the ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.Condition")," struct."),(0,i.kt)("p",null,"Golang, however, supports both structural and nominal typing. Nominal typing means that two types equivalent if and only if they have the same name. Structural typing in golang means that two types are equivalent if they have the same structure and are unnamed. So if we defined ",(0,i.kt)("inlineCode",{parentName:"p"},"Condition")," nominally it might look like ",(0,i.kt)("inlineCode",{parentName:"p"},"type Condition struct { Field1 string }")," and if we defined it structurally it would look like ",(0,i.kt)("inlineCode",{parentName:"p"},"type Condition = struct { Field1 string }"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"Condition")," were defined structurally we could use the expected keeper approach and a calling module ",(0,i.kt)("em",{parentName:"p"},"would not")," need to import ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," at all to define the ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomethingV2")," method in its expected keeper interface. Structural typing avoids the dependency problems described above."),(0,i.kt)("p",null,"We could actually extend this structural typing paradigm to protobuf generated code ",(0,i.kt)("em",{parentName:"p"},"if")," we disallow adding new fields to existing protobuf messages. This would be required because two struct types are only identical if their fields are identical. If even the order of fields in a struct or the struct tags change, then golang considers the structs as different types. While this is fairly restrictive, it is under consideration for approach A) and ",(0,i.kt)("a",{parentName:"p",href:"/main/build/rfc/rfc-002-zero-copy-encoding"},"RFC 002")," as well and has gained a fair amount of support."),(0,i.kt)("p",null,"Small modifications to the existing pulsar code generator could potentially generate code that uses structural typing and moves the implementation of protobuf interfaces to wrapper types because unnamed structs can't define methods. Here's an example of what this might look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type MsgDoSomething = struct {\n    Sender string\n    Amount uint64\n}\n\ntype MsgDoSomething_Message(*MsgDoSomething)\n\n// MsgDoSomething_Message would actually implement protobuf methods\nvar _ proto.Message = (*MsgDoSomething_Message)(nil)\n")),(0,i.kt)("p",null,"At least at the message layer, such an API wouldn't pose a problem because the transaction decoder does message decoding and modules wouldn't need to interact with the ",(0,i.kt)("inlineCode",{parentName:"p"},"proto.Message")," interface directly."),(0,i.kt)("p",null,"In order to avoid problems with the global protobuf registry, the structural typing generated code would only register message descriptors with the global registry but not register message types. This would allow two modules to generate the same protobuf types in different packages without causing a conflict. Because the types are defined structurally, they would actually be the ",(0,i.kt)("em",{parentName:"p"},"same")," types but no direct import would be required. In order to ensure compatibility, when message descriptors are registered at startup, a check would be required to ensure that messages are identical (i.e. no new fields)."),(0,i.kt)("p",null,"With this approach, a module ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," calling module ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," could either import ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," directly to get its types or generate its own set of compatible types for ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),"s API. The dependency problem is essentially solved with this approach without needing any sort of special discipline around a separate API module. The main discipline would be around versioning protobuf APIs correctly and not adding new fields."),(0,i.kt)("p",null,"Taking this approach one step further, we could potentially even define APIs that unwrap the request and response types, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomething(context.Context, string, uint64) error")," vs ",(0,i.kt)("inlineCode",{parentName:"p"},"DoSomething(context.Context, MsgDoSomething) (MsgDoSomethingResponse, error)"),". Or, APIs could even be defined directly in golang and the ",(0,i.kt)("inlineCode",{parentName:"p"},".proto")," files plus marshaling code could be generated via ",(0,i.kt)("inlineCode",{parentName:"p"},"go generate"),". Ex:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package foo \n\nimport "context"\n\n//go:generate go run github.com/cosmos/cosmos-proto/cmd/structproto\n\ntype Msg interface {\n    DoSomething(context.Context, string, uint64) error\n}\n')),(0,i.kt)("p",null,"While having the limitation of not allowing new fields to be added to existing structs, approach E) has the following benefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"unlike approach A), api types can be generated in the same go module, but direct imports can always be avoided"),(0,i.kt)("li",{parentName:"ul"},"generated client/server code could look more like regular go interfaces (without needing a set of intermediate structs)"),(0,i.kt)("li",{parentName:"ul"},"keeper interface defined in ",(0,i.kt)("inlineCode",{parentName:"li"},".go")," files could be turned into protobuf APIs (rather than needing to write ",(0,i.kt)("inlineCode",{parentName:"li"},".proto")," files)"),(0,i.kt)("li",{parentName:"ul"},"SDK modules could adopt go semantic versioning without any of the issues described above, achieving the initially stated goals of this ADR")),(0,i.kt)("h2",{id:"decision"},"Decision"),(0,i.kt)("p",null,"There has been no decision yet, and the SDK has more or less been following approach C) and official adoption of ",(0,i.kt)("a",{parentName:"p",href:"https://0ver.org"},"0ver")," as a policy has been discussed. The issue of decoupling modules, properly versioning protobuf types, avoiding breakage, and adopting semver continue to arise from time to time. The most serious alternatives under consideration currently are approaches A) and E). The remainder of this ADR has been left blank and will be filled in when and if there is further convergence on a solution."),(0,i.kt)("h2",{id:"consequences"},"Consequences"),(0,i.kt)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,i.kt)("h3",{id:"positive"},"Positive"),(0,i.kt)("h3",{id:"negative"},"Negative"),(0,i.kt)("h3",{id:"neutral"},"Neutral"),(0,i.kt)("h2",{id:"further-discussions"},"Further Discussions"),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/discussions/10162"},"https://github.com/cosmos/cosmos-sdk/discussions/10162")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/discussions/10582"},"https://github.com/cosmos/cosmos-sdk/discussions/10582")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/discussions/10368"},"https://github.com/cosmos/cosmos-sdk/discussions/10368")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/pull/11340"},"https://github.com/cosmos/cosmos-sdk/pull/11340")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/issues/11899"},"https://github.com/cosmos/cosmos-sdk/issues/11899")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/main/build/architecture/adr-020-protobuf-transaction-encoding"},"ADR 020")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"))))}c.isMDXComponent=!0}}]);