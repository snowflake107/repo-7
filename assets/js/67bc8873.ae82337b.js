"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[53539],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||o;return n?a.createElement(u,s(s({ref:t},d),{},{components:n})):a.createElement(u,s({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[p]="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},66064:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_position:1},s="Transaction Lifecycle",r={unversionedId:"learn/beginner/tx-lifecycle",id:"version-0.52/learn/beginner/tx-lifecycle",title:"Transaction Lifecycle",description:"This document describes the lifecycle of a transaction from creation to committed state changes. Transaction definition is described in a different doc. The transaction is referred to as Tx.",source:"@site/versioned_docs/version-0.52/learn/beginner/01-tx-lifecycle.md",sourceDirName:"learn/beginner",slug:"/learn/beginner/tx-lifecycle",permalink:"/v0.52/learn/beginner/tx-lifecycle",draft:!1,tags:[],version:"0.52",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Anatomy of a Cosmos SDK Application",permalink:"/v0.52/learn/beginner/app-anatomy"},next:{title:"Query Lifecycle",permalink:"/v0.52/learn/beginner/query-lifecycle"}},l={},c=[{value:"Transaction Creation",id:"transaction-creation",level:2},{value:"Gas and Fees",id:"gas-and-fees",level:3},{value:"CLI Example",id:"cli-example",level:3},{value:"Other Transaction Creation Methods",id:"other-transaction-creation-methods",level:3},{value:"Transaction Broadcasting",id:"transaction-broadcasting",level:2},{value:"Transaction Processing",id:"transaction-processing",level:2},{value:"Decoding",id:"decoding",level:3},{value:"Routing",id:"routing",level:3},{value:"Example of Routing",id:"example-of-routing",level:3},{value:"Validation",id:"validation",level:3},{value:"Types of Transaction Checks",id:"types-of-transaction-checks",level:4},{value:"ValidateBasic (deprecated)",id:"validatebasic-deprecated",level:4},{value:"Discard or Addition to Mempool",id:"discard-or-addition-to-mempool",level:3},{value:"Module Execution",id:"module-execution",level:3},{value:"State Changes During Consensus",id:"state-changes-during-consensus",level:3},{value:"Inclusion in a Block",id:"inclusion-in-a-block",level:2},{value:"Post-Transaction Handling",id:"post-transaction-handling",level:2},{value:"Learn More",id:"learn-more",level:2}],d={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"transaction-lifecycle"},"Transaction Lifecycle"),(0,i.kt)("admonition",{title:"Synopsis",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This document describes the lifecycle of a transaction from creation to committed state changes. Transaction definition is described in a ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/advanced/transactions"},"different doc"),". The transaction is referred to as ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx"),".")),(0,i.kt)("admonition",{title:"Pre-requisite Readings",type:"note"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/v0.52/learn/beginner/app-anatomy"},"Anatomy of a Cosmos SDK Application")))),(0,i.kt)("h2",{id:"transaction-creation"},"Transaction Creation"),(0,i.kt)("p",null,"One of the main application interfaces is the command-line interface. The transaction ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx")," can be created by the user inputting a command in the following format from the ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/advanced/cli"},"command-line"),", providing the type of transaction in ",(0,i.kt)("inlineCode",{parentName:"p"},"[command]"),", arguments in ",(0,i.kt)("inlineCode",{parentName:"p"},"[args]"),", and configurations such as gas prices in ",(0,i.kt)("inlineCode",{parentName:"p"},"[flags]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"[appname] tx [command] [args] [flags]\n")),(0,i.kt)("p",null,"This command automatically ",(0,i.kt)("strong",{parentName:"p"},"creates")," the transaction, ",(0,i.kt)("strong",{parentName:"p"},"signs")," it using the account's private key, and ",(0,i.kt)("strong",{parentName:"p"},"broadcasts")," it to the specified peer node."),(0,i.kt)("p",null,"There are several required and optional flags for transaction creation. The ",(0,i.kt)("inlineCode",{parentName:"p"},"--from")," flag specifies which ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/beginner/accounts"},"account")," the transaction is originating from. For example, if the transaction is sending coins, the funds are drawn from the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," address."),(0,i.kt)("h3",{id:"gas-and-fees"},"Gas and Fees"),(0,i.kt)("p",null,"Additionally, there are several ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/advanced/cli"},"flags")," users can use to indicate how much they are willing to pay in ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/beginner/gas-fees"},"fees"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--gas")," refers to how much ",(0,i.kt)("a",{parentName:"li",href:"/v0.52/learn/beginner/gas-fees"},"gas"),", which represents computational resources, ",(0,i.kt)("inlineCode",{parentName:"li"},"Tx")," consumes. Gas is dependent on the transaction and is not precisely calculated until execution, but can be estimated by providing ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")," as the value for ",(0,i.kt)("inlineCode",{parentName:"li"},"--gas"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--gas-adjustment")," (optional) can be used to scale ",(0,i.kt)("inlineCode",{parentName:"li"},"gas")," up in order to avoid underestimating. For example, users can specify their gas adjustment as 1.5 to use 1.5 times the estimated gas."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--gas-prices")," specifies how much the user is willing to pay per unit of gas, which can be one or multiple denominations of tokens. For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"--gas-prices=0.025uatom, 0.025upho")," means the user is willing to pay 0.025uatom AND 0.025upho per unit of gas."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--fees")," specifies how much in fees the user is willing to pay in total."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--timeout-timestamp")," specifies a block timeout timestamp to prevent the tx from being committed past a certain time.")),(0,i.kt)("p",null,"The ultimate value of the fees paid is equal to the gas multiplied by the gas prices. In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"fees = ceil(gas * gasPrices)"),". Thus, since fees can be calculated using gas prices and vice versa, the users specify only one of the two."),(0,i.kt)("p",null,"Later, validators decide whether or not to include the transaction in their block by comparing the given or calculated ",(0,i.kt)("inlineCode",{parentName:"p"},"gas-prices")," to their local ",(0,i.kt)("inlineCode",{parentName:"p"},"min-gas-prices"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx")," is rejected if its ",(0,i.kt)("inlineCode",{parentName:"p"},"gas-prices")," is not high enough, so users are incentivized to pay more."),(0,i.kt)("h3",{id:"cli-example"},"CLI Example"),(0,i.kt)("p",null,"Users of the application ",(0,i.kt)("inlineCode",{parentName:"p"},"app")," can enter the following command into their CLI to generate a transaction to send 1000uatom from a ",(0,i.kt)("inlineCode",{parentName:"p"},"senderAddress")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"recipientAddress"),". The command specifies how much gas they are willing to pay: an automatic estimate scaled up by 1.5 times, with a gas price of 0.025uatom per unit gas."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"appd tx send <recipientAddress> 1000uatom --from <senderAddress> --gas auto --gas-adjustment 1.5 --gas-prices 0.025uatom\n")),(0,i.kt)("h3",{id:"other-transaction-creation-methods"},"Other Transaction Creation Methods"),(0,i.kt)("p",null,"The command-line is an easy way to interact with an application, but ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx")," can also be created using a ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/advanced/grpc_rest"},"gRPC or REST interface")," or some other entry point defined by the application developer. From the user's perspective, the interaction depends on the web interface or wallet they are using (e.g. creating ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx")," using ",(0,i.kt)("a",{parentName:"p",href:"https://www.keplr.app/"},"Keplr")," and signing it with any ",(0,i.kt)("a",{parentName:"p",href:"https://www.ledger.com/"},"Ledger device"),")."),(0,i.kt)("h2",{id:"transaction-broadcasting"},"Transaction Broadcasting"),(0,i.kt)("p",null,"This is the next phase, where a transaction is sent from a client (such as a wallet or a command-line interface) to the network of nodes. This process is consensus-agnostic, meaning it can work with various consensus engines."),(0,i.kt)("p",null,"Below are the steps involved in transaction broadcasting:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Transaction Creation and Signing:"),"\nTransactions are created and signed using the client's private key to ensure authenticity and integrity.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Broadcasting to the Network:"),"\nThe signed transaction is sent to the network. This is handled by the ",(0,i.kt)("inlineCode",{parentName:"p"},"BroadcastTx")," function in the client context.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Network Propagation:"),"\nOnce received by a node, the transaction is propagated to other nodes in the network. This ensures that all nodes have a copy of the transaction.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Consensus Engine Interaction:"),"\nThe specific method of broadcasting may vary depending on the consensus engine used. The SDK's design allows for easy integration with any consensus engine by configuring the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientCtx")," appropriately."))),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"BroadcastTx")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"client/tx/tx.go")," demonstrates how a transaction is prepared, signed, and broadcasted. Here's the relevant part of the function that handles the broadcasting:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"res, err := clientCtx.BroadcastTx(txBytes)\nif err != nil {\n return err\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Configuration:")),(0,i.kt)("p",null,"To adapt this function for different consensus engines, ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientCtx")," is configured with the correct network settings and transaction handling mechanisms for your chosen engine. This might involve setting up specific encoders, decoders, and network endpoints that are compatible with the engine."),(0,i.kt)("h2",{id:"transaction-processing"},"Transaction Processing"),(0,i.kt)("p",null,"After a transaction is broadcasted to the network, it undergoes several processing steps to ensure its validity. These steps are managed by the application's core transaction processing layer, which is responsible for handling transactions. Within the SDK, this core layer is wrapped with a runtime layer defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"runtime/app.go"),". This layer extends the core functionality with additional features to handle transactions, allowing for more flexibility and customization, such as the ability to swap out different consensus engines. The key steps in transaction processing are:"),(0,i.kt)("h3",{id:"decoding"},"Decoding"),(0,i.kt)("p",null,"The transaction is decoded from its binary format into a structured format that the application can understand."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"During Transaction Processing:")," Transactions are received in the encoded ",(0,i.kt)("inlineCode",{parentName:"li"},"[]byte")," form. Nodes first unmarshal the transaction using the configuration defined in the app, then proceed to execute the transaction, which includes state changes.")),(0,i.kt)("h3",{id:"routing"},"Routing"),(0,i.kt)("p",null,"How Routing Works:\nThe transaction is routed to the appropriate module based on the message type. Each message type is associated with a specific module, which is responsible for processing the message. The core transaction processing layer uses a ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgServiceRouter")," to direct the transaction to the correct module."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Transaction Type Identification:"),"\nEach transaction contains one or more messages (",(0,i.kt)("inlineCode",{parentName:"li"},"sdk.Msg"),"), and each message has a ",(0,i.kt)("inlineCode",{parentName:"li"},"Type()")," method that identifies its type. This type is used to determine the appropriate module to handle the message."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Module Routing:"),"\nThe core transaction processing layer holds a ",(0,i.kt)("inlineCode",{parentName:"li"},"MsgServiceRouter")," which maps each message type to a specific module's handler. When a transaction is processed, this router is used to direct the message to the correct module.")),(0,i.kt)("h3",{id:"example-of-routing"},"Example of Routing"),(0,i.kt)("p",null,"Let's say there is a transaction that involves transferring tokens. The message type might be ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend"),", and the ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgServiceRouter")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseApp")," would route this message to the bank module's handler. The bank module would then validate the transaction details (like sender balance) and update the state to reflect the transfer if valid..."),(0,i.kt)("h3",{id:"validation"},"Validation"),(0,i.kt)("p",null,"Preliminary checks are performed. These include signature verification to ensure the transaction hasn't been tampered with and checking if the transaction meets the minimum fee requirements, which is handled by the ",(0,i.kt)("inlineCode",{parentName:"p"},"AnteHandler"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"AnteHandler")," is invoked during the ",(0,i.kt)("inlineCode",{parentName:"p"},"runTx")," method in ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseApp"),"."),(0,i.kt)("h4",{id:"types-of-transaction-checks"},"Types of Transaction Checks"),(0,i.kt)("p",null,"During the transaction lifecycle, full-nodes perform a series of checks to validate transactions before they are finalized in a block. These checks are categorized into stateless and stateful checks."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Stateless Checks"),":\nStateless checks are validations that do not require access to the state of the blockchain. They are computationally inexpensive and can be performed by light clients or offline nodes. Examples include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ensuring addresses are not empty."),(0,i.kt)("li",{parentName:"ul"},"Enforcing nonnegative values for transaction fields."),(0,i.kt)("li",{parentName:"ul"},"Validating the format of the data in the transaction.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Stateful Checks"),":\nStateful checks involve validating transactions against the current committed state of the blockchain. These checks are more computationally intensive as they require access to the state. Examples include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Verifying that the account has sufficient funds."),(0,i.kt)("li",{parentName:"ul"},"Checking that the sender has the necessary permissions for the transaction."),(0,i.kt)("li",{parentName:"ul"},"Ensuring that the transaction does not result in any state conflicts.")),(0,i.kt)("p",null,"Full-nodes use these checks during the validation process to quickly reject invalid transactions, minimizing wasted computational resources. Further validation occurs during the transaction execution phase, where transactions are fully executed."),(0,i.kt)("h4",{id:"validatebasic-deprecated"},"ValidateBasic (deprecated)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Messages (",(0,i.kt)("a",{parentName:"li",href:"/v0.52/learn/advanced/transactions#messages"},(0,i.kt)("inlineCode",{parentName:"a"},"sdk.Msg")),") are extracted from transactions (",(0,i.kt)("inlineCode",{parentName:"li"},"Tx"),"). The ",(0,i.kt)("inlineCode",{parentName:"li"},"ValidateBasic")," method of the ",(0,i.kt)("inlineCode",{parentName:"li"},"sdk.Msg")," interface implemented by the module developer is run for each transaction."),(0,i.kt)("li",{parentName:"ul"},"To discard obviously invalid messages, the ",(0,i.kt)("inlineCode",{parentName:"li"},"BaseApp")," type calls the ",(0,i.kt)("inlineCode",{parentName:"li"},"ValidateBasic")," method very early in the processing of the message in the ",(0,i.kt)("a",{parentName:"li",href:"/v0.52/learn/advanced/baseapp#checktx"},(0,i.kt)("inlineCode",{parentName:"a"},"CheckTx"))," and ",(0,i.kt)("inlineCode",{parentName:"li"},"DeliverTx")," transactions.\n",(0,i.kt)("inlineCode",{parentName:"li"},"ValidateBasic")," can include only ",(0,i.kt)("strong",{parentName:"li"},"stateless")," checks (the checks that do not require access to the state). ")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ValidateBasic")," method on messages has been deprecated in favor of validating messages directly in their respective ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/build/building-modules/msg-services#validation"},(0,i.kt)("inlineCode",{parentName:"a"},"Msg")," services"),"."),(0,i.kt)("p",{parentName:"admonition"},"Read ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/main/rfc/rfc-001-tx-validation"},"RFC 001")," for more details.")),(0,i.kt)("h3",{id:"discard-or-addition-to-mempool"},"Discard or Addition to Mempool"),(0,i.kt)("p",null,"If at any point during the initial transaction validation the transaction (",(0,i.kt)("inlineCode",{parentName:"p"},"Tx"),") fails, it is discarded, and the transaction lifecycle ends there. Otherwise, if it passes this preliminary check successfully, the general protocol is to relay it to peer nodes and add it to the node's transaction pool (often referred to as the mempool). This makes the ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx")," a candidate for inclusion in the next block, pending further consensus processes."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"app-side mempool"),", serves the purpose of keeping track of transactions seen by all full-nodes. Full-nodes maintain a ",(0,i.kt)("strong",{parentName:"p"},"mempool cache")," of the last ",(0,i.kt)("inlineCode",{parentName:"p"},"mempool.cache_size")," transactions they have seen, serving as a first line of defense to prevent replay attacks. Ideally, ",(0,i.kt)("inlineCode",{parentName:"p"},"mempool.cache_size")," should be large enough to encompass all transactions in the full mempool. If the mempool cache is too small to track all transactions, the initial transaction validation process is responsible for identifying and rejecting replayed transactions."),(0,i.kt)("p",null,"Currently existing preventative measures include fees and a ",(0,i.kt)("inlineCode",{parentName:"p"},"sequence")," (nonce) counter to distinguish replayed transactions from identical but valid ones. If an attacker tries to spam nodes with many copies of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx"),", full-nodes maintaining a transaction cache reject all identical copies. Even if the copies have incremented sequence numbers, attackers are disincentivized by the need to pay fees."),(0,i.kt)("p",null,"Validator nodes maintain a transaction pool to prevent replay attacks, similar to full-nodes, but also use it to hold unconfirmed transactions in preparation for block inclusion. It's important to note that even if a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tx")," passes all preliminary checks, it can still be found invalid later on, as these initial checks do not fully execute the transaction's logic."),(0,i.kt)("h3",{id:"module-execution"},"Module Execution"),(0,i.kt)("p",null,"After the transaction has been appropriately routed to the correct module by the ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgServiceRouter")," and passed all necessary validations, the execution phase begins:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Handler Activation"),": Each module's handler processes the routed message, applying the necessary business logic such as updating account balances or transferring tokens."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"State Changes"),": Handlers may modify the state as required by the business logic, which could involve writing to the module's portion of the state store. This can be seen in the next subsection."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Event Emission and Logging"),": During execution, modules can emit events and log information, which are crucial for monitoring and querying transaction outcomes.")),(0,i.kt)("p",null,"For messages that adhere to older standards or specific formats, a routing function retrieves the route name from the message, identifying the corresponding module. The message is then processed by the designated handler within that module, ensuring accurate and consistent application of the transaction's logic."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"During the execution, the module's handler will modify the state as required by the business logic. This could involve writing to the module's portion of the state store.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Modules can emit events and log information during execution, which are used for monitoring and querying transaction outcomes."))),(0,i.kt)("p",null,"During the module execution phase, each message that has been routed to the appropriate module is processed according to the module-specific business logic. For example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"handleMsgSend")," function in the bank module processes ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgSend")," messages by checking balances, transferring tokens, and emitting events:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func handleMsgSend(ctx sdk.Context, keeper BankKeeper, msg MsgSend) error {\n    if keeper.GetBalance(ctx, msg.Sender).Amount < msg.Amount {\n        return sdkerrors.Wrap(sdkerrors.ErrInsufficientFunds, "sender does not have enough tokens")\n    }\n    keeper.SendCoins(ctx, msg.Sender, msg.Receiver, msg.Amount)\n    ctx.EventManager().EmitEvent(\n        sdk.NewEvent("transfer", sdk.NewAttribute("from", msg.Sender.String()), sdk.NewAttribute("to", msg.Receiver.String()), sdk.NewAttribute("amount", msg.Amount.String())),\n    )\n    return nil\n}\n')),(0,i.kt)("p",null,"This function exemplifies how a module's handler executes the transaction logic, modifies the state, and logs the transaction events, which are essential aspects of module execution."),(0,i.kt)("h3",{id:"state-changes-during-consensus"},"State Changes During Consensus"),(0,i.kt)("p",null,"Before finalizing the transactions within a block, full-nodes perform a second round of checks using ",(0,i.kt)("inlineCode",{parentName:"p"},"validateBasicMsgs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AnteHandler"),". This is crucial to ensure that all transactions are valid, especially since a malicious proposer might include invalid transactions. Unlike the checks during the transaction addition to the Mempool, the ",(0,i.kt)("inlineCode",{parentName:"p"},"AnteHandler")," in this phase does not compare the transaction's ",(0,i.kt)("inlineCode",{parentName:"p"},"gas-prices")," to the node's ",(0,i.kt)("inlineCode",{parentName:"p"},"min-gas-prices"),". This is because ",(0,i.kt)("inlineCode",{parentName:"p"},"min-gas-prices")," can vary between nodes, and using them here would lead to nondeterministic results across the network."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"After module execution, the transactions are included in a block proposal by the proposer.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"All full-nodes that receive this block proposal execute the transactions to ensure that the state changes are applied consistently across all nodes, maintaining the deterministic nature of the blockchain. This includes the execution of initial, transaction-specific, and finalizing operations."))),(0,i.kt)("h2",{id:"inclusion-in-a-block"},"Inclusion in a Block"),(0,i.kt)("p",null,"Consensus is the process through which nodes in a blockchain network agree on which transactions to include in the blockchain. This process typically occurs in rounds, starting with a designated node (often called a proposer) compiling a block from transactions in its transaction pool (mempool). The block is then proposed to other nodes (validators) in the network."),(0,i.kt)("p",null,"Each validator independently verifies the proposed block against the blockchain's rules. If the block is accepted by a sufficient number of validators according to the network's consensus rules, it is added to the blockchain. If not, the process may repeat, potentially with a different proposer or even resulting in a block that contains no transactions (a nil block)."),(0,i.kt)("p",null,"The specific mechanisms of choosing a proposer, the criteria for a valid block, and the method of achieving agreement among validators can vary depending on the consensus algorithm used by the blockchain."),(0,i.kt)("h2",{id:"post-transaction-handling"},"Post-Transaction Handling"),(0,i.kt)("p",null,"After execution, any additional actions that need to be taken are processed. This could include updating logs, sending events, or handling errors."),(0,i.kt)("p",null,"These steps are managed by ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseApp")," in the Cosmos SDK, which routes transactions to the appropriate handlers and manages state transitions."),(0,i.kt)("p",null,"After a transaction is executed in the Cosmos SDK, several steps are taken to finalise the process:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Event Emission: Modules emit events that can be used for logging, monitoring, or triggering other workflows. These events are collected during the transaction execution.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Logging: Information about the transaction execution, such as success or failure, and any significant state changes, are logged for audit and diagnostic purposes.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Error Handling: If any errors occur during transaction execution, they are handled appropriately, which may include rolling back certain operations to maintain state consistency.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"State Commitment: Changes made to the state during the transaction are finalised and written to the blockchain. This step is crucial as it ensures that all state transitions are permanently recorded.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"PostHandlers: After the execution of the message, ",(0,i.kt)("inlineCode",{parentName:"p"},"PostHandlers")," are run. If they fail, the state changes made during ",(0,i.kt)("inlineCode",{parentName:"p"},"runMsgs")," and by the ",(0,i.kt)("inlineCode",{parentName:"p"},"PostHandlers")," themselves are both reverted. This ensures that only successful transactions affect the state."))),(0,i.kt)("p",null,"After post-transaction handling, the exact sequence of the transaction lifecycle is dependent on the consensus mechanism used. This includes how transactions are grouped into blocks, how blocks are validated, and how consensus is achieved among validators to commit the block to the blockchain. Each consensus protocol may implement these steps differently to ensure network agreement and maintain the integrity of the blockchain state."),(0,i.kt)("h2",{id:"learn-more"},"Learn More"),(0,i.kt)("p",null,"For a deeper dive into the underlying mechanisms of transaction processing and block commitment in the Cosmos SDK, consider exploring the ",(0,i.kt)("a",{parentName:"p",href:"/v0.52/learn/advanced/baseapp"},"BaseApp documentation"),". This advanced documentation provides detailed insights into the internal workings and state management of the Cosmos SDK."))}h.isMDXComponent=!0}}]);