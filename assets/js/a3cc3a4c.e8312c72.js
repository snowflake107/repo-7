"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[61310],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=d(n),u=a,h=m["".concat(l,".").concat(u)]||m[u]||p[u]||s;return n?i.createElement(h,r(r({ref:t},c),{},{components:n})):i.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:a,r[1]=o;for(var d=2;d<s;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},60323:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));const s={},r="ADR 074: Messages with Implicit Signers",o={unversionedId:"build/architecture/adr-074-implicit-msg-signers",id:"build/architecture/adr-074-implicit-msg-signers",title:"ADR 074: Messages with Implicit Signers",description:"Changelog",source:"@site/docs/build/architecture/adr-074-implicit-msg-signers.md",sourceDirName:"build/architecture",slug:"/build/architecture/adr-074-implicit-msg-signers",permalink:"/main/build/architecture/adr-074-implicit-msg-signers",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"buildSidebar",previous:{title:"ADR 073: Built-in In-process Indexer",permalink:"/main/build/architecture/adr-073-indexer"},next:{title:"ADR {ADR-NUMBER}:",permalink:"/main/build/architecture/adr-template"}},l={},d=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Abstract",id:"abstract",level:2},{value:"Context",id:"context",level:2},{value:"Alternatives",id:"alternatives",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Further Discussions",id:"further-discussions",level:2},{value:"References",id:"references",level:2}],c={toc:d},m="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adr-074-messages-with-implicit-signers"},"ADR 074: Messages with Implicit Signers"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2024-06-10: Initial draft")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"PROPOSED Not Implemented"),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,"This ADR introduces a new ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgV2")," standard where the signer of the message is implied by the\ncredentials of the party sending it, and unlike the current design not part of the message body.\nThis can be used for both simple inter-module message passing and simpler messages in transactions."),(0,a.kt)("h2",{id:"context"},"Context"),(0,a.kt)("p",null,"Historically operations in the SDK have been modelled with the ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.Msg")," interface and\nthe account signing the message has to be explicitly extracted from the body of ",(0,a.kt)("inlineCode",{parentName:"p"},"Msg"),"s.\nOriginally this was via a ",(0,a.kt)("inlineCode",{parentName:"p"},"GetSigners")," method on the ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.Msg")," interface which returned\ninstances of ",(0,a.kt)("inlineCode",{parentName:"p"},"sdk.AccAddress")," which itself relied on a global variable for decoding\nthe addresses from bech32 strings. This was a messy situation. In addition, the implementation\nfor ",(0,a.kt)("inlineCode",{parentName:"p"},"GetSigners")," was different for each ",(0,a.kt)("inlineCode",{parentName:"p"},"Msg")," type and clients would need to do a custom\nimplementation for each ",(0,a.kt)("inlineCode",{parentName:"p"},"Msg")," type. These were improved somewhat with the introduction of\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"cosmos.msg.v1.signer")," protobuf option which allowed for a more standardised way of\ndefining who the signer of a message was and its implementation in the ",(0,a.kt)("inlineCode",{parentName:"p"},"x/tx")," module which\nextracts signers dynamically and allowed removing the dependency on the global bech32\nconfiguration."),(0,a.kt)("p",null,"Still this design introduces a fair amount of complexity. For instance, inter-module message\npassing (",(0,a.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"),") has been in discussion for years\nwithout much progress and one of the main blockers is figuring out how to properly authenticate\nmessages in a performant and consistent way. With embedded message signers there will always need\nto be a step of extracting the signer and then checking with the module sending is actually\nauthorized to perform the operation. With dynamic signer extraction, although the system is\nmore consistent, more performance overhead is introduced. In any case why should an inter-module\nmessage passing system need to do so much conversion, parsing, etc. just to check if a message\nis authenticated? In addition, we have the complexity where modules can actually have many valid\naddresses. How are we to accommodate this? Should there be a lookup into ",(0,a.kt)("inlineCode",{parentName:"p"},"x/auth")," to check if an\naddress belongs to a module or not? All of these thorny questions are delaying the delivery of\ninter-module message passing because we do not want an implementation that is overly complex.\nThere are many use cases for inter-module message passing which are still relevant, the most\nimmediate of which is a more robust denom management system in ",(0,a.kt)("inlineCode",{parentName:"p"},"x/bank")," ",(0,a.kt)("inlineCode",{parentName:"p"},"v2")," which is being explored\nin ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/pull/20316"},"ADR 071"),"."),(0,a.kt)("h2",{id:"alternatives"},"Alternatives"),(0,a.kt)("p",null,"Alternatives that have been considered are extending the current ",(0,a.kt)("inlineCode",{parentName:"p"},"x/tx")," signer extraction system\nto inter-module message passing as defined in ",(0,a.kt)("a",{parentName:"p",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"),"."),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("p",null,"We have decided to introduce a new ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgV2")," standard whereby the signer of the message is implied\nby the credentials of the party sending it. These messages will be distinct from the existing messages\nand define new semantics with the understanding that signers are implicit."),(0,a.kt)("p",null,"In the case of messages passed internally by a module or ",(0,a.kt)("inlineCode",{parentName:"p"},"x/account")," instance, the signer of a message\nwill simply be the main root address of the module or account sending the message. An interface for\nsafely passing such messages to the message router will need to be defined."),(0,a.kt)("p",null,"In the case of messages passed externally in transactions, ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgV2")," instances will need to be wrapped\nin a ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgV2")," envelope:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},"message MsgV2 {\n  string signer = 1;\n  google.protobuf.Any msg = 2;  \n}\n")),(0,a.kt)("p",null,"Because the ",(0,a.kt)("inlineCode",{parentName:"p"},"cosmos.msg.v1.signer")," annotation is required currently, ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgV2")," types should set the message option\n",(0,a.kt)("inlineCode",{parentName:"p"},"cosmos.msg.v2.is_msg")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," instead."),(0,a.kt)("p",null,"Here is an example comparing a v1 an v2 message:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},'// v1\nmessage MsgSendV1 {\n  option (cosmos.msg.v1.signer) = "from_address";\n  string from_address = 1 ;\n  string to_address = 2;\n  repeated Coin amount = 3;\n}\n\n// v2\nmessage MsgSendV2 {\n  option (cosmos.msg.v2.is_msg) = true;\n  // from address is implied by the signer\n  string to_address = 1;\n  repeated Coin amount = 2;\n}\n')),(0,a.kt)("p",null,"Modules defining handlers for ",(0,a.kt)("inlineCode",{parentName:"p"},"MsgV2")," instances will need to extract the sender from the ",(0,a.kt)("inlineCode",{parentName:"p"},"context.Context")," that is\npassed in. An interface in ",(0,a.kt)("inlineCode",{parentName:"p"},"core")," which will be present on the ",(0,a.kt)("inlineCode",{parentName:"p"},"appmodule.Environment")," will be defined for this purpose:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type GetSenderService interface {\n  GetSender(ctx context.Context) []byte\n}\n")),(0,a.kt)("p",null,"Sender addresses that are returned by the service will be simple ",(0,a.kt)("inlineCode",{parentName:"p"},"[]byte")," slices and any bech32 conversion will be\ndone by the framework."),(0,a.kt)("h2",{id:"consequences"},"Consequences"),(0,a.kt)("h3",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,a.kt)("p",null,"This design does not depreciate the existing method of embedded signers in ",(0,a.kt)("inlineCode",{parentName:"p"},"Msg"),"s and is totally compatible with it."),(0,a.kt)("h3",{id:"positive"},"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Allows for a simple inter-module communication design which can be used soon for the ",(0,a.kt)("inlineCode",{parentName:"li"},"bank")," ",(0,a.kt)("inlineCode",{parentName:"li"},"v2")," redesign."),(0,a.kt)("li",{parentName:"ul"},"Allows for simpler client implementations for messages in the future.")),(0,a.kt)("h3",{id:"negative"},"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"There will be two message designs and developers will need to pick between them.")),(0,a.kt)("h3",{id:"neutral"},"Neutral"),(0,a.kt)("h2",{id:"further-discussions"},"Further Discussions"),(0,a.kt)("p",null,"Two possible directions that have been proposed are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"allowing for the omission of the ",(0,a.kt)("inlineCode",{parentName:"li"},"cosmos.msg.v2.is_msg")," option and assuming any ",(0,a.kt)("inlineCode",{parentName:"li"},"Msg"),"s registered that do not include ",(0,a.kt)("inlineCode",{parentName:"li"},"cosmos.msg.v1.signer")," are ",(0,a.kt)("inlineCode",{parentName:"li"},"MsgV2")," instances. The pitfall is that this could be incorrect if ",(0,a.kt)("inlineCode",{parentName:"li"},"Msg")," v1 behavior is actually decided but the user forgot the ",(0,a.kt)("inlineCode",{parentName:"li"},"cosmos.msg.v1.signer")," option."),(0,a.kt)("li",{parentName:"ol"},"allow ",(0,a.kt)("inlineCode",{parentName:"li"},"Msg")," v1 instances to be wrapped in a ",(0,a.kt)("inlineCode",{parentName:"li"},"MsgV2")," envelope as well to simplify things client-side. In this scenario we would need to either a) check that the signer in the envelope and the signer in the message are the same or b) allow the signer in the message to be empty and then set it inside the state machine before it reaches the module. While this may be easier for some clients, it may introduce unexpected behavior with Ledger signing via Amino JSON or SIGN_MODE_TEXTUAL. ")),(0,a.kt)("p",null,"Both of these are seem as quality of life improvements for some users, but not strictly necessary and could have some pitfalls so further discussion is needed."),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/main/build/architecture/adr-033-protobuf-inter-module-comm"},"ADR 033"))))}p.isMDXComponent=!0}}]);