"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[40263],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=i,g=p["".concat(l,".").concat(u)]||p[u]||m[u]||o;return n?a.createElement(g,r(r({ref:t},d),{},{components:n})):a.createElement(g,r({ref:t},d))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},96452:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_position:1},r="x/tx",s={unversionedId:"build/modules/tx/README",id:"build/modules/tx/README",title:"x/tx",description:"Abstract",source:"@site/docs/build/modules/tx/README.md",sourceDirName:"build/modules/tx",slug:"/build/modules/tx/",permalink:"/main/build/modules/tx/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"buildSidebar",previous:{title:"x/staking",permalink:"/main/build/modules/staking/"},next:{title:"x/upgrade",permalink:"/main/build/modules/upgrade/"}},l={},c=[{value:"Abstract",id:"abstract",level:2},{value:"Contents",id:"contents",level:2},{value:"Signing",id:"signing",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Decode",id:"decode",level:2},{value:"Key Features",id:"key-features-1",level:3},{value:"DecodedTx",id:"decodedtx",level:3},{value:"Class Diagram",id:"class-diagram",level:3},{value:"Decode Sequence Diagram",id:"decode-sequence-diagram",level:3},{value:"Disclaimer",id:"disclaimer",level:2}],d={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"xtx"},"x/tx"),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"This document specifies the tx module of the Cosmos SDK."),(0,i.kt)("p",null,"The package is a crucial component of the Cosmos SDK, providing essential functionality for handling transactions\nwithin the Cosmos ecosystem. It offers support for transaction decoding, allowing for parsing and interpretation of\ntransaction data. The package implements compatibility with ADR-027 for application-defined raw transaction\nserialization, ensuring proper field ordering and encoding. A key feature of the package is its implementation of\nvarious signing handlers. These handlers provide different methods for generating sign bytes. It also includes APIs for\ncustom signer definitions, allowing developers to tailor the signing process to their specific needs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"x/tx")," is not a traditional Cosmos SDK module (it's not an AppModule)."),(0,i.kt)("h2",{id:"contents"},"Contents"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#xtx"},"x/tx"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#abstract"},"Abstract")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#contents"},"Contents")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#signing"},"Signing"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#key-features"},"Key Features")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#decode"},"Decode"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#key-features-1"},"Key Features")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#decodedtx"},"DecodedTx")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#class-diagram"},"Class Diagram")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#decode-sequence-diagram"},"Decode Sequence Diagram")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#disclaimer"},"Disclaimer"))))),(0,i.kt)("h2",{id:"signing"},"Signing"),(0,i.kt)("p",null,"The signing package handles the process of providing the bytes to be signed for transactions. It provides a set of\ninterfaces and implementations for different signing modes and methods."),(0,i.kt)("p",null,"In summary, the signing package is responsible for preparing the data to be signed according to different signing modes,\nbut doesn't handle the actual signing process (i.e., applying a cryptographic signature to these bytes)."),(0,i.kt)("h3",{id:"key-features"},"Key Features"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"SignModeHandler Interface: this is the core interface that defines how different signing modes should be implemented."),(0,i.kt)("li",{parentName:"ol"},"SignModeHandler Implementations:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.50.7/docs/architecture/adr-020-protobuf-transaction-encoding.md#sign_mode_legacy_amino"},"aminojson")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.50.7/docs/architecture/adr-020-protobuf-transaction-encoding.md#sign_mode_direct"},"direct")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.50.7/docs/architecture/adr-020-protobuf-transaction-encoding.md#sign_mode_direct_aux"},"direct aux")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.50.7/docs/architecture/adr-050-sign-mode-textual-annex1.md#adr-050-sign_mode_textual-annex-1-value-renderers"},"textual")))),(0,i.kt)("li",{parentName:"ol"},"Context: the signing Context provides necessary information for retrieving signers from messages and resolving protobuf types."),(0,i.kt)("li",{parentName:"ol"},"TxData and SignerData: these structures contain the necessary data for generating sign bytes. TxData includes transaction details, while SignerData contains information about the signer."),(0,i.kt)("li",{parentName:"ol"},"HandlerMap: a collection of SignModeHandlers, allowing the system to support multiple signing modes.")),(0,i.kt)("h2",{id:"decode"},"Decode"),(0,i.kt)("p",null,"The decode package provides functionality for decoding raw transaction bytes into structured transaction data. It's\ndesigned to work with transactions that follow the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.50.7/docs/architecture/adr-027-deterministic-protobuf-serialization.md#adr-027-deterministic-protobuf-serialization"},"ADR-027"),"\nspecification for application-defined raw transaction serialization."),(0,i.kt)("h3",{id:"key-features-1"},"Key Features"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Transaction Decoding: Parses raw transaction bytes into a structured ",(0,i.kt)("inlineCode",{parentName:"li"},"DecodedTx")," object."),(0,i.kt)("li",{parentName:"ol"},"ADR-027 Compatibility: Ensures compatibility with the ADR-027 specification."),(0,i.kt)("li",{parentName:"ol"},"Unknown Field Handling: Rejects unknown fields in TxRaw and AuthInfo, while allowing non-critical unknown fields in TxBody."),(0,i.kt)("li",{parentName:"ol"},"Signer Extraction: Extracts and deduplicates signers from transaction messages."),(0,i.kt)("li",{parentName:"ol"},"Support for Dynamic Messages: Handles both protobuf dynamic messages and gogoproto messages.")),(0,i.kt)("h3",{id:"decodedtx"},"DecodedTx"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DecodedTx")," is a struct that represents a decoded transaction by implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction.Tx"),". It contains various\ncomponents of a transaction after it has been parsed from its raw bytes. Here's a breakdown of its structure:"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DecodedTx")," struct has the following fields:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"DynamicMessages: A slice of proto.Message interfaces, representing the transaction messages in a dynamic format. "),(0,i.kt)("li",{parentName:"ol"},"Messages: A slice of gogoproto.Message interfaces, representing the transaction messages in the gogo protobuf format. "),(0,i.kt)("li",{parentName:"ol"},"Tx: A pointer to a v1beta1.Tx struct, which represents the full transaction in the Cosmos SDK v1beta1 format. "),(0,i.kt)("li",{parentName:"ol"},"TxRaw: A pointer to a v1beta1.TxRaw struct, representing the raw transaction data. "),(0,i.kt)("li",{parentName:"ol"},"Signers: A slice of byte slices, containing the addresses of the transaction signers. "),(0,i.kt)("li",{parentName:"ol"},"TxBodyHasUnknownNonCriticals: A boolean flag indicating whether the transaction body contains unknown non-critical fields.")),(0,i.kt)("p",null,"The DecodedTx struct also implements several methods to satisfy the ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction.Tx")," interface, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Hash()"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"GetGasLimit()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"GetMessages()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"GetSenders()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bytes()"),". These methods allow the DecodedTx to be used in places\nwhere a transaction is expected. The purpose of this struct is to provide a comprehensive representation of a decoded\ntransaction, making it easier for other parts of the system to work with transaction data in a structured format."),(0,i.kt)("h3",{id:"class-diagram"},"Class Diagram"),(0,i.kt)("mermaid",{value:"classDiagram\n    class DecodedTx {\n        DynamicMessages: []proto.Message\n        Messages: []gogoproto.Message\n        Tx: *v1beta1.Tx\n        TxRaw: *v1beta1.TxRaw\n        Signers: [][]byte\n        TxBodyHasUnknownNonCriticals: bool\n        cachedHash: [32]byte\n        cachedBytes: []byte\n        cachedHashed: bool\n        Hash() [32]byte\n        GetGasLimit() (uint64, error)\n        GetMessages() ([]transaction.Msg, error)\n        GetSenders() ([][]byte, error)\n        Bytes() []byte\n        computeHashAndBytes()\n    }\n\n    class Decoder {\n        signingCtx: *signing.Context\n        codec: gogoProtoCodec\n        Decode(txBytes []byte) (*DecodedTx, error)\n    }\n\n    class Options {\n        SigningContext: *signing.Context\n        ProtoCodec: gogoProtoCodec\n    }\n\n    class gogoProtoCodec {\n        <<interface>>\n        Unmarshal([]byte, gogoproto.Message) error\n    }\n\nDecodedTx --|> `transaction.Tx` : implements\nDecoder ..> DecodedTx : creates\nDecoder o-- `signing.Context` : uses\nDecoder o-- gogoProtoCodec : uses\nOptions --* Decoder : used to create"}),(0,i.kt)("h3",{id:"decode-sequence-diagram"},"Decode Sequence Diagram"),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    participant C as Client\n    participant D as Decoder\n    participant R as Raw (v1beta1.TxRaw)\n    participant B as Body (v1beta1.TxBody)\n    participant A as AuthInfo (v1beta1.AuthInfo)\n    participant T as Tx (v1beta1.Tx)\n    participant DT as DecodedTx\n\n    C->>+D: Decode(txBytes)\n    D->>D: rejectNonADR027TxRaw(txBytes)\n    D->>D: RejectUnknownFieldsStrict(txBytes, raw)\n    D->>R: proto.Unmarshal(txBytes, &raw)\n    D->>D: RejectUnknownFields(raw.BodyBytes, body)\n    D->>B: proto.Unmarshal(raw.BodyBytes, &body)\n    D->>D: RejectUnknownFieldsStrict(raw.AuthInfoBytes, authInfo)\n    D->>A: proto.Unmarshal(raw.AuthInfoBytes, &authInfo)\n    D->>T: Create Tx\n    loop For each message in body.Messages\n        D->>D: Unmarshal dynamic message\n        D->>D: Unmarshal gogoproto message\n        D->>D: Get signers\n    end\n    D->>DT: Create DecodedTx\n    D--\x3e>-C: Return DecodedTx"}),(0,i.kt)("h2",{id:"disclaimer"},"Disclaimer"),(0,i.kt)("p",null,"It's important to clarify that ",(0,i.kt)("inlineCode",{parentName:"p"},"x/tx")," is distinct from ",(0,i.kt)("inlineCode",{parentName:"p"},"x/auth/tx"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x/tx"),": This package (the one described in this README) provides core transaction handling functionality."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x/auth/tx"),": This is a separate package and is typically used in the context of building a complete tx is that is going to be broadcast in Cosmos SDK applications.")),(0,i.kt)("p",null,'When you see a "tx" module referenced in ',(0,i.kt)("inlineCode",{parentName:"p"},"app_config.go")," or similar application configuration files, it refers to\n",(0,i.kt)("inlineCode",{parentName:"p"},"x/auth/tx/config"),", not ",(0,i.kt)("inlineCode",{parentName:"p"},"x/tx")," (as it's not an Appmodule). This naming similarity can be confusing, so it's crucial to pay\nattention to the import paths and context when working with these packages."))}m.isMDXComponent=!0}}]);