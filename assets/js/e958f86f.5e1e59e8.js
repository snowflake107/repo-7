"use strict";(self.webpackChunkcosmos_sdk_docs=self.webpackChunkcosmos_sdk_docs||[]).push([[40562],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),u=o,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8143:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const i={sidebar_position:1},r="Keepers",s={unversionedId:"build/building-modules/keeper",id:"version-0.52/build/building-modules/keeper",title:"Keepers",description:"Keepers refer to a Cosmos SDK abstraction whose role is to manage access to the subset of the state defined by various modules. Keepers are module-specific, i.e. the subset of state defined by a module can only be accessed by a keeper defined in said module. If a module needs to access the subset of state defined by another module, a reference to the second module's internal keeper needs to be passed to the first one. This is done in app.go during the instantiation of module keepers.",source:"@site/versioned_docs/version-0.52/build/building-modules/06-keeper.md",sourceDirName:"build/building-modules",slug:"/build/building-modules/keeper",permalink:"/v0.52/build/building-modules/keeper",draft:!1,tags:[],version:"0.52",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"buildSidebar",previous:{title:"ProtocolBuffer Annotations",permalink:"/v0.52/build/building-modules/protobuf-annotations"},next:{title:"PreBlocker, BeginBlocker and EndBlocker",permalink:"/v0.52/build/building-modules/preblock-beginblock-endblock"}},l={},d=[{value:"Motivation",id:"motivation",level:2},{value:"Type Definition",id:"type-definition",level:2},{value:"Implementing Methods",id:"implementing-methods",level:2},{value:"State Management",id:"state-management",level:2}],p={toc:d},c="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"keepers"},"Keepers"),(0,o.kt)("admonition",{title:"Synopsis",type:"note"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"Keeper"),"s refer to a Cosmos SDK abstraction whose role is to manage access to the subset of the state defined by various modules. ",(0,o.kt)("inlineCode",{parentName:"p"},"Keeper"),"s are module-specific, i.e. the subset of state defined by a module can only be accessed by a ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," defined in said module. If a module needs to access the subset of state defined by another module, a reference to the second module's internal ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," needs to be passed to the first one. This is done in ",(0,o.kt)("inlineCode",{parentName:"p"},"app.go")," during the instantiation of module keepers.")),(0,o.kt)("admonition",{title:"Pre-requisite Readings",type:"note"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/v0.52/build/building-modules/intro"},"Introduction to Cosmos SDK Modules")))),(0,o.kt)("h2",{id:"motivation"},"Motivation"),(0,o.kt)("p",null,"The Cosmos SDK is a framework that makes it easy for developers to build complex decentralized applications from scratch, mainly by composing modules together. As the ecosystem of open-source modules for the Cosmos SDK expands, it will become increasingly likely that some of these modules contain vulnerabilities, as a result of the negligence or malice of their developer."),(0,o.kt)("p",null,"The Cosmos SDK adopts an ",(0,o.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/main/learn/advanced/ocap#ocaps-in-practice"},"object-capabilities-based approach")," to help developers better protect their application from unwanted inter-module interactions, and ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s are at the core of this approach. A ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," can be considered quite literally to be the gatekeeper of a module's store(s). Each store (typically an ",(0,o.kt)("a",{parentName:"p",href:"/v0.52/learn/advanced/store#iavl-store"},(0,o.kt)("inlineCode",{parentName:"a"},"IAVL")," Store"),") defined within a module comes with a ",(0,o.kt)("inlineCode",{parentName:"p"},"storeKey"),", which grants unlimited access to it. The module's ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," holds this ",(0,o.kt)("inlineCode",{parentName:"p"},"storeKey")," (which should otherwise remain unexposed), and defines ",(0,o.kt)("a",{parentName:"p",href:"#implementing-methods"},"methods")," for reading and writing to the store(s)."),(0,o.kt)("p",null,"The core idea behind the object-capabilities approach is to only reveal what is necessary to get the work done. In practice, this means that instead of handling permissions of modules through access-control lists, module ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s are passed a reference to the specific instance of the other modules' ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s that they need to access (this is done in the ",(0,o.kt)("a",{parentName:"p",href:"/v0.52/learn/beginner/app-anatomy#constructor-function"},"application's constructor function"),"). As a consequence, a module can only interact with the subset of state defined in another module via the methods exposed by the instance of the other module's ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),". This is a great way for developers to control the interactions that their own module can have with modules developed by external developers."),(0,o.kt)("h2",{id:"type-definition"},"Type Definition"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s are generally implemented in a ",(0,o.kt)("inlineCode",{parentName:"p"},"/keeper/keeper.go")," file located in the module's folder. By convention, the type ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," of a module is simply named ",(0,o.kt)("inlineCode",{parentName:"p"},"Keeper")," and usually follows the following structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type Keeper struct {\n    // External keepers, if any\n\n    // Store key(s)\n\n    // codec\n\n    // authority \n}\n")),(0,o.kt)("p",null,"For example, here is the type definition of the ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," from the ",(0,o.kt)("inlineCode",{parentName:"p"},"staking")," module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go",metastring:"reference",reference:!0},"https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.1/x/staking/keeper/keeper.go#L54-L115 \n")),(0,o.kt)("p",null,"Let us go through the different parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An expected ",(0,o.kt)("inlineCode",{parentName:"li"},"keeper")," is a ",(0,o.kt)("inlineCode",{parentName:"li"},"keeper")," external to a module that is required by the internal ",(0,o.kt)("inlineCode",{parentName:"li"},"keeper")," of said module. External ",(0,o.kt)("inlineCode",{parentName:"li"},"keeper"),"s are listed in the internal ",(0,o.kt)("inlineCode",{parentName:"li"},"keeper"),"'s type definition as interfaces. These interfaces are themselves defined in an ",(0,o.kt)("inlineCode",{parentName:"li"},"expected_keepers.go")," file in the root of the module's folder. In this context, interfaces are used to reduce the number of dependencies, as well as to facilitate the maintenance of the module itself."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KVStoreService"),"s grant access to the store(s) of the ",(0,o.kt)("a",{parentName:"li",href:"/v0.52/learn/advanced/store"},"multistore")," managed by the module. They should always remain unexposed to external modules."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cdc")," is the ",(0,o.kt)("a",{parentName:"li",href:"/v0.52/learn/advanced/encoding"},"codec")," used to marshal and unmarshal structs to/from ",(0,o.kt)("inlineCode",{parentName:"li"},"[]byte"),". The ",(0,o.kt)("inlineCode",{parentName:"li"},"cdc")," can be any of ",(0,o.kt)("inlineCode",{parentName:"li"},"codec.BinaryCodec"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"codec.JSONCodec")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"codec.Codec")," based on your requirements. It can be either a proto or amino codec as long as they implement these interfaces."),(0,o.kt)("li",{parentName:"ul"},"The authority listed is a module account or user account that has the right to change module level parameters. Previously this was handled by the param module, which has been deprecated.")),(0,o.kt)("p",null,"Of course, it is possible to define different types of internal ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s for the same module (e.g. a read-only ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"). Each type of ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper")," comes with its own constructor function, which is called from the ",(0,o.kt)("a",{parentName:"p",href:"/v0.52/learn/beginner/app-anatomy"},"application's constructor function"),". This is where ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s are instantiated, and where developers make sure to pass correct instances of modules' ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s to other modules that require them."),(0,o.kt)("h2",{id:"implementing-methods"},"Implementing Methods"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Keeper"),"s primarily expose methods for business logic, as validity checks should have already been performed by the ",(0,o.kt)("a",{parentName:"p",href:"/v0.52/build/building-modules/msg-services"},(0,o.kt)("inlineCode",{parentName:"a"},"Msg")," server")," when ",(0,o.kt)("inlineCode",{parentName:"p"},"keeper"),"s' methods are called."),(0,o.kt)("p",null,"State management is recommended to be done via ",(0,o.kt)("a",{parentName:"p",href:"../packages/collections"},"Collections")," "),(0,o.kt)("h2",{id:"state-management"},"State Management"),(0,o.kt)("p",null,"In the Cosmos SDK, it is crucial to be methodical and selective when managing state within a module, as improper state management can lead to inefficiency, security risks, and scalability issues. Not all data belongs in the on-chain state; it's important to store only essential blockchain data that needs to be verified by consensus. Storing unnecessary information, especially client-side data, can bloat the state and slow down performance. Instead, developers should focus on using an off-chain database to handle supplementary data, extending the API as needed. This approach minimizes on-chain complexity, optimizes resource usage, and keeps the blockchain state lean and efficient, ensuring scalability and smooth operations."),(0,o.kt)("p",null,"The Cosmos SDK leverages Protocol Buffers (protobuf) for efficient state management, providing a well-structured, binary encoding format that ensures compatibility and performance across different modules. The SDK\u2019s recommended approach for managing state is through the ",(0,o.kt)("a",{parentName:"p",href:"../pacakges/02-collections.md"},"collections package"),", which simplifies state handling by offering predefined data structures like maps and indexed sets, reducing the complexity of managing raw state data. While users can opt for custom encoding schemes if they need more flexibility or have specialized requirements, they should be aware that such custom implementations may not integrate seamlessly with indexers that decode state data on the fly. This could lead to challenges in data retrieval, querying, and interoperability, making protobuf a safer and more future-proof choice for most use cases."))}m.isMDXComponent=!0}}]);